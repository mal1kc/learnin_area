#+title: Threading in Python
#+author: mal1kc
#+property: header-args :tangle threading_example.py
#+auto_tangle: t
#+startup: showeverything

* Python Threads

** what are threads
threads refers to thread of execution in computer program

#+BEGIN_QUOTE
Thread: The operating system object that executess the instructions of a process
- book: page 273,the art of concurency,2009.
#+END_QUOTE

when we run python script, it starts an instance of python interpreter that runs our code in the main thread.
the main threads is the default thread of a python process

we may develop our program to  perform tasks concurently in that case we may need threads,these are concurent threads of execution without our program
example of this will be:

- execution funtion calls concurently
- execution object methods concurently

a python thread is an object representation of native thread provided by operating system

when we create and run a new thread, Python will make system calls on the underlaying op. system and request new thread be created and start running new thread

the code in new threads may or may not be executed in parallel,even though the threads are executed concurently.

these are number of reasons for this,such as:

- the underlaying hardware may or may not support parallel execution (e.g. one vs multiple CPU cores)
- the python interpreter may or may not permity multiple threads execute in parallel

> this highlights the distiction between concurent and parallel execution

- *Concurrent* : Code that can be executed out of order
- *Parallel* : Capability to execute code simultaneously

** thread vs process

a process refers to a computer process

#+BEGIN_QUOTE
process: the operating system's spawned and controlled entity that encapsulates an executing application.
a process has two main functions. the first is to act as the resource holder for the applicatio,
and the second is to execute the instructions of the application.
- book: page 271,the art of concurency,2009
#+END_QUOTE

the op system controls how new processes are created on some system,that may require spawning a new process,and on others,it may require that process is forked.
in Cpython implementation we not need to worry because python interpreter is manage
creating new processes.

a thread always exists within a process and represents the manner in which instructions or code is executed.

a process will have at least one thread, called the main thread.Any additional
threads that we create within the process will belong to that process.

the python process will terminate once all(non background threads) are terminated

- *process*: an instance of the python interpreter has atleast one thread called MainThread
- *thread*: a thread of execution within Python process,such as the MainThread or new thread.

** life-cycle of thread

a thread in python is object instanced from  *threading.Thread* class

once a thead is started, interpreter will interface with the operating system and request that new native thread be created. the instance of *threading.Thread*
the provides a python-based reference to his underlaying native thread.

each thread follows same life-cycle . understanding of its life-cycle help with
concurent programming in python.

for example:

- the diffrence between creatimg and starting a thread

- the diffrence between run and start

- the diffrence between blocked and terminated

while running, the thread may be executing code or may be blocked,waiting on something such as another thread or external resouce.although, not all threads may block, it is optinal base on specific use case for the new thread.

1. new thread
2. running thread
    1. blocked thread (optinal).
3. terminated thread.

A new thread is a thread that has been constructed by. creating an instance of the *threading.Thread* class

a new thread can transition to a running thread by calling the start() function.

a running thread may block in many ways, such as reading or writing from a file or a socket or by waiting on concurency primitive such as semaphore or a lock
after blocking,the thread will run again.

finaly, a thread may terminate once it has finished executing its code or by raising
error or exception

[[(thread life cycle diaram)./thread-life-cycle.webp]]

* run a func in thread

python funcs can executed in a seperatie thread using *threading.Thread* class

** how to run a func in thread

the func executed in another thread may have args in which case can be specificed as aa tuple and passed to the "*args*" argument of the threading.threading class constructor or as dictionart to the "*kwargs*" argument.

the *start()* func will return immediately and the operating system will execute    the function in a seperate thread as soon as it is able.

we do not have control over when the thread will execute precisely or which cpu core wwill execute it. both of these are low-level responsibilities that are handled by operating systeÃ¶.

> examle :

#+begin_src python :shebang "#!/bin/env python" :tangle threading_example.py

import threading
import time

print('example 1\n'+('-'*21))
def task1():
    # block for 1 second
    time.sleep(1)
    # display a message

    print('this is from another thread')


def example1():
    thread = threading.Thread(target=task1)
    thread.start()
    print('waiting fo the thread ..')
    thread.join() # explicitly waiting to finish thread

example1()
print('-'*32)
#+end_src

#+RESULTS:
: None

running the example first creates instance  of threeding.Thread then calls the *start()* func.This does not start the thread immediately,but instead allows to operating system to schedule the function to execute as soon as possible.

the main thread then prints a message '/waiting .../' ,then calls the *join()* function to explicitly block and wait for the new thread to finish executing.

> example with arguments

#+begin_src python :shebang "#!/bin/env python" :tangle threading_example.py

print('example 2\n'+('-'*21))
def task2(sleep_time,message):
    # block for 1 second
    time.sleep(sleep_time)
    # display a message
    print(message)


def example2():
    thread = threading.Thread(target=task2,args=(1.5,'new message from another thread'))
    thread.start()
    print('waiting fo the thread ..')
    thread.join() # explicitly waiting to finish thread

example2()

print('-'*32)
#+end_src

* extend the thread class

* resouces

 - https://superfastpython.com/threading-in-python/#Python_Threads

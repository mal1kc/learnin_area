#+title: Threading in Python
#+author: mal1kc
#+property: header-args :tangle threading_example.py
#+auto_tangle: t
#+startup: showeverything

* Python Threads

** what are threads
threads refers to thread of execution in computer program

#+BEGIN_QUOTE
Thread: The operating system object that executess the instructions of a process
- book: page 273,the art of concurency,2009.
#+END_QUOTE

when we run python script, it starts an instance of python interpreter that runs our code in the main thread.
the main threads is the default thread of a python process

we may develop our program to  perform tasks concurently in that case we may need threads,these are concurent threads of execution without our program
example of this will be:

- execution funtion calls concurently
- execution object methods concurently

a python thread is an object representation of native thread provided by operating system

when we create and run a new thread, Python will make system calls on the underlaying op. system and request new thread be created and start running new thread

the code in new threads may or may not be executed in parallel,even though the threads are executed concurently.

these are number of reasons for this,such as:

- the underlaying hardware may or may not support parallel execution (e.g. one vs multiple CPU cores)
- the python interpreter may or may not permity multiple threads execute in parallel

> this highlights the distiction between concurent and parallel execution

- *Concurrent* : Code that can be executed out of order
- *Parallel* : Capability to execute code simultaneously

** thread vs process

a process refers to a computer process

#+BEGIN_QUOTE
process: the operating system's spawned and controlled entity that encapsulates an executing application.
a process has two main functions. the first is to act as the resource holder for the applicatio,
and the second is to execute the instructions of the application.
- book: page 271,the art of concurency,2009
#+END_QUOTE

the op system controls how new processes are created on some system,that may require spawning a new process,and on others,it may require that process is forked.
in Cpython implementation we not need to worry because python interpreter is manage
creating new processes.

a thread always exists within a process and represents the manner in which instructions or code is executed.

a process will have at least one thread, called the main thread.Any additional
threads that we create within the process will belong to that process.

the python process will terminate once all(non background threads) are terminated

- *process*: an instance of the python interpreter has atleast one thread called MainThread
- *thread*: a thread of execution within Python process,such as the MainThread or new thread.

** life-cycle of thread

a thread in python is object instanced from  *threading.Thread* class

once a thead is started, interpreter will interface with the operating system and request that new native thread be created. the instance of *threading.Thread*
the provides a python-based reference to his underlaying native thread.

each thread follows same life-cycle . understanding of its life-cycle help with
concurent programming in python.

for example:

- the diffrence between creatimg and starting a thread

- the diffrence between run and start

- the diffrence between blocked and terminated

while running, the thread may be executing code or may be blocked,waiting on something such as another thread or external resouce.although, not all threads may block, it is optinal base on specific use case for the new thread.

1. new thread
2. running thread
    1. blocked thread (optinal).
3. terminated thread.

A new thread is a thread that has been constructed by. creating an instance of the *threading.Thread* class

a new thread can transition to a running thread by calling the start() function.

a running thread may block in many ways, such as reading or writing from a file or a socket or by waiting on concurency primitive such as semaphore or a lock
after blocking,the thread will run again.

finaly, a thread may terminate once it has finished executing its code or by raising
error or exception

[[(thread life cycle diaram)./thread-life-cycle.webp]]

* run a func in thread

python funcs can executed in a seperatie thread using *threading.Thread* class

** how to run a func in thread

the func executed in another thread may have args in which case can be specificed as aa tuple and passed to the "*args*" argument of the threading.threading class constructor or as dictionart to the "*kwargs*" argument.

the *start()* func will return immediately and the operating system will execute    the function in a seperate thread as soon as it is able.

we do not have control over when the thread will execute precisely or which cpu core wwill execute it. both of these are low-level responsibilities that are handled by operating systeÃ¶.

> examle :

#+begin_src python :shebang "#!/bin/env python" :tangle threading_example.py

import threading
import time
from pprint import pprint

print('example 1\n'+('-'*21))
def task1():
    # block for 1 second
    time.sleep(1)
    # display a message

    print('this is from another thread')


def example1():
    thread = threading.Thread(target=task1)
    thread.start()
    print('waiting fo the thread ..')
    thread.join() # explicitly waiting to finish thread

example1()
print('-'*32)
#+end_src

#+RESULTS:
: None

running the example first creates instance  of threeding.Thread then calls the *start()* func.This does not start the thread immediately,but instead allows to operating system to schedule the function to execute as soon as possible.

the main thread then prints a message '/waiting .../' ,then calls the *join()* function to explicitly block and wait for the new thread to finish executing.

> example with arguments

#+begin_src python :shebang "#!/bin/env python" :tangle threading_example.py

print('example 2\n'+('-'*21))
def task2(sleep_time,message):
    # block for 1 second
    time.sleep(sleep_time)
    # display a message
    print(message)


def example2():
    thread = threading.Thread(target=task2,args=(1.5,'new message from another thread'))
    thread.start()
    print('waiting fo the thread ..')
    thread.join() # explicitly waiting to finish thread

example2()

print('-'*32)
#+end_src

* extend the thread class

we can also execute funcs in another thread by extending the *threading.Thread* class and overriding the run() function.

In this section we will look at some examples of extending *thread.Thread* class

** possible usage cases

given that it is a custom class,you can defina a constructor for the class and use it to pass in data that may be needed in the *run()* function, stored as instance variables (attributes).

you can also define additional functions on the class to split up the work you may need to complete another thread.

finally, attributes caan also be used to store the results of any calculation or IO performed in another thread that may be need to be retrieved afterward.

** example of extending the thread class

example code :

#+begin_example
class CustomThread(Thread):
    ...
#+end_example

this will inherit *Thread* class to our *CustomThread* class,then we need override
*run()* func to execute another threads funcs,overriding a function very basic as syntax:

#+begin_example
def run(self):
    sleep(1)
    print('this is coming from another thread')

# create the thread
thread = CustomThread()

# start the thread

thread.start()

# wait for the thread finish

print('waiting for the thread to finish')

thread.join()

#+end_example


complete code would be like:

#+begin_src python :shebang "#!/bin/env python" :tangle threading_example.py

print('example 3\n'+('-'*21))


def example3():
    class CustomThread(threading.Thread):
        def run(self):
            time.sleep(1)
            print('this is coming from another thread')


    thread = CustomThread()
    thread.start()
    print('waitin for thread finish')
    thread.join()

example3()
print('-'*32)

#+end_src

** example of extending the thread class with return values

#+begin_src python :shebang "#!/bin/env python" :tangle threading_example.py

print('example 4\n'+('-'*21))

def example4():
    class CustomThread(threading.Thread):
        def run(self):
            time.sleep(1)
            print('this is coming from another thread')
            self.value = 99

    thread = CustomThread()
    thread.start()
    print('waitin for thread finish')
    thread.join()
    value = thread.value
    print(f'{value=}')

example4()
print('-'*32)

#+end_src

* thread instance attributes

an instance of the thread class provides a handle of a thread of execution.
it provides attributes that we can use to query properties and the status of the underlaying thread.

** thread name

threads are named automatically in a somewhat unique manner within each process withe the form "Thread-%d" where %d is the integer indicating the thread number within the process,e.g. Thread-1 for the first thread created.

** thread daemon

a thread may be a deamon thread, daemon threads is the name givent to background threads.by default threads are non-daemon threads.

a python program will only exit when all non-daemon threads have finished exiting. for example , the main threads is a non-daemon threads.this means that daemon threads can run in the background and do not have to finish or be explicitly excited for the program end.

** thread identifier

each thread has unique identifier (id) within python process,assigned by python interpreter.

the identifier is a read-only positive integer value and is assigned only after thread has been started.

can be accesed via *"ident"* property

** thread native identifier

each thread has unique identifier assigned by the operating system.

python threads (cpython) are real native threads,means that each thread we created is actually created and managed (scheduled) by operating system.As such, the operating system will assing a unique integer to each thread that is created on the system (across processes).

can be acced via *"native_id"* property

it is assigned after thread has been started

** thread alive status

thread class property that holds is thread running or dead (non-started or finished)

in example:

#+begin_src python :shebang "#!/bin/env python" :tangle threading_example.py

print('example 5\n'+('-'*21))
def example5():
    # create instance of Thread object with lambda func
    thread = threading.Thread(target=lambda:(
        time.sleep(0.2),
        print('this is from another thread')
    ))
    # report thread alive status
    is_alive = thread.is_alive()
    print(f'thread\'s {is_alive=}')
    # report thread identifier value
    ident = thread.ident
    print(f'{ident=}')
    # report thread daemon property
    daemon = thread.daemon
    print(f'{daemon=}')
    name = thread.name
    print(f'{name=}')
    thread.start()
    # report thread native id property
    native_id = thread.native_id
    print(f'{native_id=}')
    is_alive = thread.is_alive()
    print(f'{is_alive=}')
    ident = thread.ident
    print(f'{ident=}')
    thread.join()
    is_alive = thread.is_alive()
    print(f'{is_alive=}')

example5()
print('-'*32)


#+end_src

* configure threads

** how to configue thread name

the name of a thread can be ser via the *"name"* argument in the threading.Thread constructor



** how to configue thread daemon

a thread may be configured to be a daemon or not,and most threads in concurrent programming,including the main thread,are non-daemon threads(no background threads) by default

can be configured via setting *"daemon"* argument to True in the constructor

for example:

#+begin_src python :shebang "#!/bin/env python" :tangle threading_example.py

print('example 5\n'+('-'*21))
def example6():
    thread = threading.Thread(name='daemon Thread',daemon=True,target=lambda:print(f'this message is from daemon thread'))
    print(f'{thread.daemon=}')
    print(f'{thread.name=}')
    thread.start()

example6()
print('-'*32)

#+end_src

* resouces
 - https://superfastpython.com/threading-in-python/#Python_Threads

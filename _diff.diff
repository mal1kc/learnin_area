diff --git a/.gitignore b/.gitignore
index 06a77d7..a23b905 100644
--- a/.gitignore
+++ b/.gitignore
@@ -276,4 +276,3 @@ Module.symvers
 Mkfile.old
 dkms.conf
 **/bin
-.ccls-cache/
diff --git a/ardunio/button_deneme/pseudo.txt b/ardunio/button_deneme/pseudo.txt
new file mode 100644
index 0000000..d218246
--- /dev/null
+++ b/ardunio/button_deneme/pseudo.txt
@@ -0,0 +1,12 @@
+loop()
+{
+    butonDurumu = buton ;
+    if (butonDurumu == 1){
+        
+        if (buton.durum == 1)
+        ışıgı yak
+    }else{
+        ışığı yakma
+    }
+}
+
diff --git a/c/async_io/src/async.c b/c/async_io/src/async.c
index d40d6d9..96d5935 100644
--- a/c/async_io/src/async.c
+++ b/c/async_io/src/async.c
@@ -4,17 +4,14 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-
 #define BUFFSIZE 25000
 
 struct aiocb *async_read(FILE *fp, char *buf, int bytes) {
-
   struct aiocb *aio = malloc(sizeof(struct aiocb));
-
   if (aio == NULL) {
-
     return NULL;
   }
+
   memset(aio, 0, sizeof(*aio));
 
   aio->aio_buf = buf;
@@ -23,12 +20,10 @@ struct aiocb *async_read(FILE *fp, char *buf, int bytes) {
   aio->aio_offset = 0;
 
   int result = aio_read(aio);
-
   if (result < 0) {
     free(aio);
     return NULL;
   }
-
   return aio;
 }
 
@@ -58,7 +53,7 @@ int main(int argc, char **argv) {
   ret = aio_return(aio);
   fclose(fp);
 
-  printf("while we were reading, we counted up %lu times\n", counter);
+  printf("While we were reading, we counted up %lu times\n", counter);
 
   if (ret > 0) {
     printf("got %d bytes:\n", ret);
diff --git a/c/file_operations/src/main.c b/c/file_operations/src/main.c
index 5dd87a2..2910d84 100644
--- a/c/file_operations/src/main.c
+++ b/c/file_operations/src/main.c
@@ -8,7 +8,7 @@
 **  a    for appending if file not exists create new
 **  r+   for both reading and writing
 **  w+   for both reading and writing if file exists
-**       \ truncates to zero length if not create new
+**       \ truncates to zero lenght if not create new
 **  a+   for both reading and appending if file not exist create new
 */
 
@@ -38,8 +38,8 @@ int write_file() {
   FILE *fp;
 
   fp = fopen("/tmp/test.txt", "w+");
-  fprintf(fp, "this is testing for fprintf...\n");
-  fputs("this is testing for fputs...\n", fp);
+  fprintf(fp, "This is testing for fprintf...\n");
+  fputs("This is testing for fputs...\n", fp);
   fclose(fp);
 
   return 0;
@@ -54,7 +54,7 @@ int read_file() {
   fscanf(fp, "%s", buff);
   printf("1: %s\n", buff);
 
-  // char *fgets( char *buff, int n, FILE *fp );
+  // char *fgets( char *buf, int n, FILE *fp );
   // fgets reads up to n-1 characters from file \
   // \ to buff array and appending null character
   // \ to terminate string
diff --git a/cpp/individual_things/bitwise_opeations/C-bitwise_operators.md b/cpp/individual_things/bitwise_opeations/C-bitwise_operators.md
index 814037c..dab7244 100644
--- a/cpp/individual_things/bitwise_opeations/C-bitwise_operators.md
+++ b/cpp/individual_things/bitwise_opeations/C-bitwise_operators.md
@@ -2,7 +2,7 @@
 
 > all operators in C
 >
-> * && logical AND
+> * && logial AND
 > * || logical OR
 > * ! logical NOT
 > * ^ logical XOR
@@ -14,8 +14,8 @@
 > * \>> bitwise right shift
 > * ++ increment + assign
 > * -- decrement + assign
-> * += increment + assignment
-> * -= decrement + assignment
+> * += increment + assigment
+> * -= decrement + assigment
 > * *= multiplication
 > * /= division
 > * %= modulus
diff --git a/cpp/individual_things/bitwise_opeations/bitwise_opeations.cpp b/cpp/individual_things/bitwise_opeations/bitwise_opeations.cpp
index 1bd002f..2ec717f 100644
--- a/cpp/individual_things/bitwise_opeations/bitwise_opeations.cpp
+++ b/cpp/individual_things/bitwise_opeations/bitwise_opeations.cpp
@@ -1,27 +1,28 @@
-// bitwise_operations
+// bitwise_opeations
 #pragma region Includes
-#include <bitset>
 #include <iostream>
+#include <bitset>
 #pragma endregion Includes
 
-int main(int argc, char const *argv[]) {
-  int a = 5;
-  std::cout << "a = " << a << "\n";
-  std::cout << "a << 1 = " << (a << 1) << "\n";
-  std::cout << "a << 4 = " << (a << 4) << "\n";
-  std::cout << "(a << 1) << 4 = " << ((a << 1) << 4) << "\n";
-  std::cout << "(a << 1) >> 1 = " << ((a << 1) >> 1) << "\n";
-  std::cout << "--- minimal version ---"
-            << "\n";
-  std::cout << "y << x = ( +y2^x )"
-            << "\n";
-  std::cout << "y >> x = ( -y2^x )"
-            << "\n";
+int main(int argc, char const *argv[])
+{
+    int a = 5;
+    std::cout << "a = " << a << "\n";
+    std::cout << "a << 1 = " << (a << 1) << "\n";
+    std::cout << "a << 4 = " << (a << 4) << "\n";
+    std::cout << "(a << 1) << 4 = " << ((a << 1) << 4) << "\n";
+    std::cout << "(a << 1) >> 1 = " << ((a << 1) >> 1) << "\n";
+    std::cout << "--- minimal version ---"
+              << "\n";
+    std::cout << "y << x = ( +y2^x )"
+              << "\n";
+    std::cout << "y >> x = ( -y2^x )"
+              << "\n";
 
-  a = 0b101;        // binary 101 = 5
-  int b = 0b010110; // binary 010110 = 22
-  b <<= 4;          // binary 010110 << 4 = 0101100000 = 352
-  int c = a | b;
-  std::cout << std::bitset<9>(c) << "\n";
-  return 0;
+    a = 0b101;        // binary 101 = 5
+    int b = 0b010110; // binary 010110 = 22
+    b <<= 4;          // binary 010110 << 4 = 0101100000 = 352
+    int c = a | b;
+    std::cout << std::bitset<9>(c) << "\n";
+    return 0;
 }
diff --git a/cpp/individual_things/file_operations/src/main.cpp b/cpp/individual_things/file_operations/src/main.cpp
index 8811c12..1fc039d 100644
--- a/cpp/individual_things/file_operations/src/main.cpp
+++ b/cpp/individual_things/file_operations/src/main.cpp
@@ -21,7 +21,7 @@ int write_file_Ios_filemode() {
 
   std::ofstream outf{"sample.txt", std::ios::app};
   if (!outf) {
-    std::cerr << "nope that's not right, sample.txt could not be opened for "
+    std::cerr << "nope thats not right, sample.txt could not be openeed for "
                  "writing\n";
     return 1;
   }
@@ -72,8 +72,8 @@ int read_sample() {
 }
 
 int write_sample() {
-  // ofstream is used for writing files
-  std::ofstream outf{"sample.txt"}; // created out file-stream for writing
+  // ofstream is usde for writing files
+  std::ofstream outf{"sample.txt"}; // created outfilestream for writing
 
   if (!outf) // checked for can we write
   {
diff --git a/cpp/individual_things/pointers_and_references/src/log.cpp b/cpp/individual_things/pointers_and_references/src/log.cpp
index 564389f..c3c2580 100644
--- a/cpp/individual_things/pointers_and_references/src/log.cpp
+++ b/cpp/individual_things/pointers_and_references/src/log.cpp
@@ -3,22 +3,22 @@
 #include <ostream>
 
 void Log(const char *message) {
-  std::cout << "\e[0;36m" // cyan ANSI escape sequence
+  std::cout << "\e[0;36m" // cyan ansi escape sequence
             << "[log]"
-            << "\e[1;97m" // bold white ANSI escape sequence
+            << "\e[1;97m" // bold white ansi escape sequence
             << " : " << message << "\n";
 }
 void InitLog() {
-  Log("\e[41m" // red background ANSI escape sequence
+  Log("\e[41m" // red background ansi escape sequence
       "program started"
-      "\e[0m" // reset color ANSI escape sequence
+      "\e[0m" // reset color ansi escape sequence
   );
 }
 
 void DeinitLog() {
-  Log("\e[41m" // red background ANSI escape sequence
+  Log("\e[41m" // red background ansi escape sequence
       "program finished"
-      "\e[0m" // reset color ANSI escape sequence
+      "\e[0m" // reset color ansi escape sequence
   );
   std::cout << std::endl;
 }
diff --git a/cpp/individual_things/pointers_and_references/src/main.cpp b/cpp/individual_things/pointers_and_references/src/main.cpp
index 357a67f..4c1ef81 100644
--- a/cpp/individual_things/pointers_and_references/src/main.cpp
+++ b/cpp/individual_things/pointers_and_references/src/main.cpp
@@ -2,7 +2,7 @@
 #include <iostream>
 #include <string.h>
 
-// NOTE pointers are integer numbers that stores memory addresses of other type
+// NOTE pointers are integer numbers that stores memory adresses of other type
 // of data types
 //
 // helper video source
@@ -12,20 +12,20 @@
 void p_example_1() {
   int var = 8;
   // void *ptr = nullptr; // null pointer (pointer that holds nothing)
-  void *ptr = &var; // pointer that holds var's memory address
+  void *ptr = &var; // pointer that holds var's memory adress
 
   std::cout << "ptr :" << ptr << "\n";
 }
 
 void p_example_2() {
   int var = 9;
-  // we told the compiler that pointer points memory address of
+  // we told the compiler that pointer points memory addres of
   // int type of data
   int *ptr = &var;
 
   std::cout << "pointer : " << ptr << "\n"
             << "data pointed by pointer : " << *ptr
-            << "\n"; // accessing data pointed by pointer
+            << "\n"; // accesing data pointed by pointer
   *ptr = 12;         // change variable that pointed by pointer
   std::cout << "after change :"
             << "\n\t"
@@ -33,19 +33,19 @@ void p_example_2() {
             << ptr << "\n"
             << "\t"
             << "data pointed by pointer : " << *ptr
-            << "\n"; // accessing data pointed by pointer
+            << "\n"; // accesing data pointed by pointer
 }
 
 void p_example_3() {
   char *buffer = new char[8]; // allocate 8 bytes of memory
   // 4036990 is char code for "~" character
   memset(buffer, 4036990, sizeof(*buffer)); // fills 8 bytes with 0's
-  char **ptr = &buffer; // that's double pointer (pointer that points pointer)
+  char **ptr = &buffer; // thats double pointer (pointer that points pointer)
 
   // int var = 93;
   // int *buffer = &var;
 
-  // int **ptr = &buffer; // that's double pointer (pointer that points pointer)
+  // int **ptr = &buffer; // thats double pointer (pointer that points pointer)
 
   // (void *) is used because buffer is char pointer
   std::cout << "*buffer : " << (void *)buffer << "\n"
@@ -67,25 +67,21 @@ void r_example_1() {
             << "ref : " << ref << "\n";
 }
 
-// extension funcs for r-example 2 to demonstrate reference
+// extension funcs for r-example 2 to demonstrade refrence
 // func1 that not used with ref it creates new value from copy ( func meant to
-// Increment given value)
+// Increament given value)
 void r_example_2_ext1(int value) { value++; }
-// func2 that used with ref ( func meant to  Increment given value)
-// thats wrong (no work we want) because in here first increment then reference
+// func2 that used with ref ( func meant to  Increament given value)
+// thats wrong (no work we want) beacause in here first increment then reference
 // pointer void r_example_2_ext2(int *value) { *value++; }
 void r_example_2_ext2(int *value) { (*value)++; }
-// func3 that uses automatically reference // it does nearly same thing with
-// func2
+// func3 that uses automaticly refrence // it does nearly same thing with func2
 void r_example_2_ext3(int &value) { value++; }
 
-// NOTE we need to use reference wherever we can because it looks nice 😎 and
-// clean 🆒 (for better readability)
-// FIXME IMPORTANT if we want to create ref and later we want to change ref we
-// cannot do that not like pointers
-//  Also we cannot use references without initializing (setting something while
-//  creating);
-
+// NOTE we need to use reference wherever we can because it looks nice 😎 and clean 🆒 (for better readability)
+// FIXME IMPORTANT if we want to create ref and later we want to change ref we cannot do that not like pointers
+//  Also we cannot use references without initilazing (setting something while creating);
+                              
 void r_example_2() {
   int a = 9;
   r_example_2_ext1(a);
@@ -106,7 +102,7 @@ int main(int argc, char *argv[]) {
   Log("pointers example 3 \a");
   p_example_3();
 
-  Log("references example 1\a");
+  Log("refrences example 1\a");
   r_example_1();
   Log("references example 2\a");
   r_example_2();
diff --git a/cpp/individual_things/std_lists/src/main.cpp b/cpp/individual_things/std_lists/src/main.cpp
index ceb1377..2867bee 100644
--- a/cpp/individual_things/std_lists/src/main.cpp
+++ b/cpp/individual_things/std_lists/src/main.cpp
@@ -8,10 +8,10 @@
 ** NOTE list syntax
 ** template < class Type, class Alloc = allocator<T> > class list;
 **
-**  -- > T = defines the type of element contained, any data type include user
+**  -- > T = definies the type of element contained, any data type include user
 *     |-> defined types
 **
-**  -- > Alloc = defines the type of allocator object this uses allocator class
+**  -- > Alloc = defines the type of allocator objec this uses allocator class
 **    |-> template by default
 **    |-> it is value-dependent and uses a simple memory allocation model.
 **
@@ -51,7 +51,7 @@ void example_1() {
 **
 * NOTE some list constructors
 *
-* |> default constructor --> it creates an empty list, that with zero elements
+* |> default constructor --> it creates an empty list, that with zero eleements
 *
 * |> fill constructor --> it creates a list with n elements and assigns a
 *                      |-> value of zero to each element
@@ -96,13 +96,13 @@ void example_2() {
 }
 
 /*
- * NOTE container properties
+ * NOTE container propertities
  *
  *  | property           | desc
  *  |
- *  | sequence           | sequence containers order their elements
+ *  | sequence           | sequence contaiers order their elements
  *  |                      in a strict linear sequence, elements are
- *  |                      aces by their position in the sequence
+ *  |                      acces by their position in the sequence
  *  |
  *  | doubly-linked list | every element has information on how to
  *  |                      locate previous and next elements this
diff --git a/cpp/individual_things/std_regex/src/main.cpp b/cpp/individual_things/std_regex/src/main.cpp
index dee8bb1..d5032a9 100644
--- a/cpp/individual_things/std_regex/src/main.cpp
+++ b/cpp/individual_things/std_regex/src/main.cpp
@@ -27,7 +27,7 @@
  *  std::regex_match is used to validated that string follows a pattern
  * \ (a date, a phone number, and so on)
  *
- *  std::search is used to perform the equivalent of a grep in piece of text
+ *  std::search is used to perform the equivalent of a greo in piece of text
  */
 
 int example_regexlib_usage() {
diff --git a/elisp/01-elisp-syntax.org b/elisp/01-elisp-syntax.org
index 8d3a50b..45f366d 100644
--- a/elisp/01-elisp-syntax.org
+++ b/elisp/01-elisp-syntax.org
@@ -2,7 +2,7 @@
 #+creator: mal1kc
 
 
-i suggest to read original manual from gnu.org 'https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html'
+i suggest to read orginal manual from gnu.org 'https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html'
 
 
 * nil and t
diff --git a/ex_libs/zeromq/python/pub.py b/ex_libs/zeromq/python/pub.py
deleted file mode 100644
index 4df5187..0000000
--- a/ex_libs/zeromq/python/pub.py
+++ /dev/null
@@ -1,5 +0,0 @@
-#!/usr/bin/env python3
-
-# this file uses zeromq library = https://zeromq.org/
-# to install this library you can use
-# pip install pyzmq
diff --git a/ex_libs/zeromq/python/sub.py b/ex_libs/zeromq/python/sub.py
deleted file mode 100644
index 4df5187..0000000
--- a/ex_libs/zeromq/python/sub.py
+++ /dev/null
@@ -1,5 +0,0 @@
-#!/usr/bin/env python3
-
-# this file uses zeromq library = https://zeromq.org/
-# to install this library you can use
-# pip install pyzmq
diff --git a/helper_tools/makefile/readme.md b/helper_tools/makefile/readme.md
index 015056f..94bef96 100644
--- a/helper_tools/makefile/readme.md
+++ b/helper_tools/makefile/readme.md
@@ -8,9 +8,9 @@ targets: prerequisites
     command
     command
 ```
-- the targets are filenames,separated by spaces.Typically,there's is only one per rule
+- the targets are filenames,seperated by spaces.Typically,theres is only one per rule
 - the commands are a series of steps typically used to **make** the target(s). These need to start with a tab character, not spaces.
-- the prerequisites are also filenames ,separated by spaces. These files need to exist before the commands for target run they also called dependencies
+- the prerequisites are also filenames ,seperated by spaces. These files need to exist before the commands for target run they alse called dependencies
 > exc:
 ```**make** file
 hello:
@@ -53,11 +53,11 @@ make: 'hello' is up to date.
 
 this will cause because target no supplied as argument to **make**  command
 if we supply **make** command like 'make foo' it will run foo target commands
-if we update foo.c and we try to run 'make foo' it will give this as output:
+if we update foo.c and we try to run 'make foo' it wiil give this as output:
 ```sh
 'make: 'foo' is up to date.'
 ```
-that's because foo file already exists,and that causes to not run target (not recompile foo.c file)
+thats because foo file already exists,and that causes to not run target (not recompile foo.c file)
 solution is quite simple we add filenames as prerequisite , this will cause to if foo.c modified it will recompile
 
 >> makefile
@@ -90,7 +90,7 @@ foo.c:
 - foo.o requires foo.c,so**make** searches foo.c target
 - foo.c has no dependencies,so the echo command is run
 - the cc -c command is run, because of all foo.o dependencies finished
-- the top cc command is run , because of all foo depend. is finished
+- the top cc command is run , because of all foo depen. is finished
 - thats it foo is a compiled c program
 
 __if we delete foo.c,all targets will rerun.__
@@ -133,7 +133,7 @@ file2:
 clean:
     rm -f file1 file2 some_file
 ```
-single or double quotes does not matter,but if you use them they will be stored with quotes
+single or double quotes does not matter,but if you use them they will be stored with quoetes
 this will be useful for using with commands like `printf`
 ```makefile
 foo := one two  # foo is assigned to str "one two"
@@ -195,7 +195,7 @@ comp2.o:
 
 ## automatic variables and wildcards
 
-both `*` and `%` are wildcards in make,but their meaning are compeletly different
+both `*` and `%` are wildcards in make,but their meaning are compeletly diffrent
 ### `*` wildcard
 `*`searches your filesystem for matching filenames but there was a
 `common pitfall`
@@ -230,7 +230,7 @@ four: $(wildcard *.o)
 ```
 ## `%` wildcard
 
- `%` is really useful but is somewhat confusing because of usages situations
+ `%` is really useful but is somewhat confusing because of usaged situations
  example situations
 
 - when used "matching" mode,it matches one or more characters in str. this match called stem
@@ -265,8 +265,8 @@ clean:
 ```
 
 
-## sources docs and more knowledge about makefile
+## sources docs and more knowladge about makefile
 
-source of this knowledge more about makefile
+source of this knowladge more about makefile
 `makefiletutorial` [web](https://makefiletutorial.com) [github repo](https://github.com/theicfire/makefiletutorial)
 
diff --git a/python/__new__.vs.__init__.py b/python/__new__.vs.__init__.py
index 54aa059..7159c14 100644
--- a/python/__new__.vs.__init__.py
+++ b/python/__new__.vs.__init__.py
@@ -1,5 +1,5 @@
 """
-# differences between __new__ and __init__ methods in classes
+# diffrences between __new__ and __init__ methods in classes
 
 where i learn : https://www.youtube.com/watch?v=-zsV0_QrfTw
 base src : https://github.com/mCodingLLC/VideosSampleCode/blob/master/videos/076_new_vs_init_in_python/new_vs_init.py
@@ -37,10 +37,10 @@ class LowercaseTuple(tuple):
         upper_iterable = (s.lower() for s in iterable)
         return super().__new__(cls, upper_iterable)
 
-    # this __init__ not work because tuples does not support item assignment
+    # this __init__ not work because tupples does not support item assigment
     # even in init
     #
-    # Tl-dr error: tuples are immutable,even in init
+    # Tldr error: tuples are immutable,even in init
     #   def __init__(self, iterable) -> None:
     #        print(f"init {iterable}")
     #        for i, arg in enumerate(iterable):
@@ -48,12 +48,12 @@ class LowercaseTuple(tuple):
 
 
 def example_inheriting_immutable_uppercase_tuple():
-    print("lowercase tuple")
+    print("lowecase tuple")
     print(LowercaseTuple(["HI", "THERE"]))
 
 
 class Singleton:
-    # e.g. global config object,btw this is not a good pattern to have
+    # eg global config object,btw this is not a good pattern to have
     # be cause it works like every variable is global variable
     _instance = None
 
diff --git a/python/decorators.py b/python/decorators.py
index 1ce7281..e44ed56 100644
--- a/python/decorators.py
+++ b/python/decorators.py
@@ -68,7 +68,7 @@ def time_decorator(org_func, *args_, **kwargs_):
     return wrapper_func
 
 
-@lru_cache(maxsize=5)  # this caches previously returned values
+@lru_cache(maxsize=5)  # this caches previosly returned values
 @time_decorator
 def fib(x):
     if x <= 1:
@@ -80,3 +80,6 @@ if __name__ == "__main__":
     time_decorator(welcome_User, "m")()
     print(f"{fib(40) = }")
     # welcome_User("malik")
+    # welcome_User("malenia")
+    # welcome_Customer("malik")
+    # welcome_Customer("malenia")
diff --git a/python/generators/generators.py b/python/generators/generators.py
index 12c503f..5099b8a 100644
--- a/python/generators/generators.py
+++ b/python/generators/generators.py
@@ -8,12 +8,12 @@ from typing import NamedTuple
 
 def get_values():
     # every yield function pauses until other next(next() method) call
-    yield "hello"
-    yield "word"
+    yield 'hello'
+    yield 'word'
     yield 123
     # return 42 # very uncommon to return something
-    # return doesn't return in next call
-    # it raise StopIteration: ReturnValue  Exception
+    # return doesnt return in next call
+    # it raies StopIteration: ReturnValue  Exception
     # -> this function gives StopIteration: 42
 
 
@@ -29,7 +29,6 @@ def example_get_values():
 
     # print(next(get)) StopIteration
 
-
 # generator can be used in for loops because in python for loop is like
 
 
@@ -81,33 +80,31 @@ class MyDataPoint(NamedTuple):
 # because file size not matter while reading
 # if you read line by line with generators
 
-# if file is 1GiB it doesn't matter because you reading
+# if file is 1GiB it doesnt matter because you reading
 # line by line with generator,program not hold all data in memory it holds
 # which line current line is and next line is
 
-
 def mydata_reader(file):
     for row in file:
-        cols = row.rstrip().split(",")
+        cols = row.rstrip().split(',')
         cols = [float(c) for c in cols]
         yield MyDataPoint._make(cols)
 
 
 def example_reader():
-    with open("mydata.txt") as file:
+    with open('mydata.txt') as file:
         for row in mydata_reader(file):
             print(row)
 
 
 # collatz conjecture : https://www.wikiwand.com/en/Collatz_conjecture
 
-
 def collatz(n):
     while True:
         if n % 2 == 0:
             n = n // 2
         else:
-            n = 3 * n + 1
+            n = 3*n+1
         yield n
         if n == 1:
             break
@@ -120,7 +117,7 @@ def collatz_list(n):
         if n % 2 == 0:
             n = n // 2
         else:
-            n = 3 * n + 1
+            n = 3 * n+1
         count += 1
         result.append(n)
         if n == 1:
@@ -151,8 +148,8 @@ def example_collatz():
     # list vs gen
     for i in collatz_list(n):
         if not (next(collatz_gen) == i):
-            print(f"it not work same:{next(print_collatz_gen)} == {i}")
-            # this line never work because it will work with less memory
+            print(f'it not work same:{next(print_collatz_gen)} == {i}')
+            # this line never work beacuse it will work with less memory
 
     # first = True
     # for i in collatz(n):
@@ -164,8 +161,7 @@ def example_collatz():
     #
     # print(collatz_list(n))
 
-
-# generators can be used other sequences that we know infinite
+# generators can be used other sequencess that we know infinite
 
 
 def powers_of_two():
@@ -188,26 +184,25 @@ def primes():
 
 
 def example_gen_comp():
-    squares = [x * x for x in range(5)]  # list comprehension
+    squares = [x*x for x in range(5)]  # list comprehension
     for sq in squares:
         print(sq)
 
-    squares = (x * x for x in range(5))  # generator comprehension
+    squares = (x*x for x in range(5))  # generator comprehension
     for sq in squares:
         print(sq)
 
 
 def example_composable():
-    # this all works lazily (memory efficient)
-    with open("./nums.txt") as file:
+    # this all works lazzly (memory efficent)
+    with open('./nums.txt') as file:
         nums = (row.partition("#")[0].rstrip() for row in file)
         nums = (row for row in nums if row)
-        nums = (float(row) for row in nums)
+        nums = (float(row)for row in nums)
         nums = (x for x in nums if math.isfinite((x)))
-        nums = (max(0.0, x) for x in nums)
+        nums = (max(0., x)for x in nums)
         s = sum(nums)
-        print(f"the sum is {s}")
-
+        print(f'the sum is {s}')
 
 # advanced usage of generators
 
@@ -242,7 +237,7 @@ def example_worker():
 
 def another_operator():
     # yield from (x*x for x in range(5))
-    for sq in (x * x for x in range(5)):
+    for sq in (x*x for x in range(5)):
         yield sq
 
 
@@ -271,7 +266,6 @@ def my_resource(*args):
 
 
 def main():
-    ...
     # example_get_values()
     # example_example()
     # example_reader()
diff --git a/python/metaclasses/class_construction.py b/python/metaclasses/class_construction.py
index 4a20cd6..c72247a 100644
--- a/python/metaclasses/class_construction.py
+++ b/python/metaclasses/class_construction.py
@@ -10,7 +10,7 @@ class A:
 
 
 def make_A():
-    # how class make
+    # how class maked
     name = "A"
     bases = ()
 
@@ -45,7 +45,7 @@ def make_A_more_accurate():
     return A
 
 
-# metaclasses is point of customization in class creation progress
+# metaclasses is point of custumization in class creation progress
 
 
 class MyMetaClass(type):
diff --git a/python/monad_example.py b/python/monad_example.py
index b8340b7..c0f06c2 100644
--- a/python/monad_example.py
+++ b/python/monad_example.py
@@ -101,8 +101,8 @@ def main():
     # what is monad good for ?
     #
     #   make composition of functions easier
-    #   avoid repeating computational patterns
-    #   particularly useful when pipelining operations
+    #   avoid repeating coöputational patterns
+    #   paricularly useful when pipelininig operations
 
     # how to define monad:
     #
diff --git a/python/requirments.txt b/python/requirments.txt
deleted file mode 100644
index 8fd8867..0000000
--- a/python/requirments.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-autopep8
-pycodestyle
-toml
-ipython
diff --git a/python/socket/app-clnt.py b/python/socket/app-clnt.py
deleted file mode 100644
index 7ddc1e3..0000000
--- a/python/socket/app-clnt.py
+++ /dev/null
@@ -1,81 +0,0 @@
-#!/usr/bin/env python3
-import sys
-import socket
-import selectors
-import traceback
-
-import libclnt
-
-sel = selectors.DefaultSelector()
-
-
-def create_request(action: str, value: str) -> dict:
-    """
-    create dict object by given args
-    - WARN there was a bug in this func the value can't be bytes object
-    """
-    if action == "search":
-        return dict(
-            type="text/json",
-            encoding="utf-8",
-            content=dict(action=action, value=value),
-        )
-    else:
-        return dict(
-            type="binary/custom-client-binary-type",
-            encoding="binary",
-            content=bytes(
-                action + value, encoding="utf-8"
-            ),  #  - WARN there was a bug in 'action + value' the value can't be bytes object
-        )
-
-
-def start_connection(host: str, port: int, request: dict):
-    """
-    connects given connection (host,port) and sends given request
-    """
-    addr = (host, port)
-    print(f"Starting connection to {addr}")
-    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-    sock.setblocking(False)
-    sock.connect_ex(addr)
-    events = selectors.EVENT_READ | selectors.EVENT_WRITE
-    message = libclnt.Message(sel, sock, addr, request)
-    sel.register(sock, events, data=message)
-
-
-def main():
-
-    if len(sys.argv) != 5:
-        print(f"usage: {sys.argv[0]} <host> <port> <action> <value>")
-        sys.exit(1)
-
-    host, port = sys.argv[1], int(sys.argv[2])
-    action, value = sys.argv[3], sys.argv[4]
-    request = create_request(action, value)
-    start_connection(host, port, request)
-
-    try:
-        while True:
-            events = sel.select(timeout=1)
-            for key, mask in events:
-                message = key.data
-                try:
-                    message.process_events(mask)
-                except Exception:
-                    print(
-                        f"main: error: exception for {message.addr}:\n"
-                        f"{traceback.format_exc()}"
-                    )
-                    message.close()
-            # check for a socket being monitored to continue.
-            if not sel.get_map():
-                break
-    except KeyboardInterrupt:
-        print("caught keyboard interrupt, exiting")
-    finally:
-        sel.close()
-
-
-if __name__ == "__main__":
-    main()
diff --git a/python/socket/app-srvr.py b/python/socket/app-srvr.py
deleted file mode 100644
index a1da1fa..0000000
--- a/python/socket/app-srvr.py
+++ /dev/null
@@ -1,59 +0,0 @@
-#!/usr/bin/env python3
-import sys
-import socket
-import selectors
-import traceback
-
-import libsrvr
-
-sel = selectors.DefaultSelector()
-
-
-def accept_wrapper(sock):
-    conn, addr = sock.accept()  # Should be ready to read
-    print(f"accepted connection from {addr}")
-    conn.setblocking(False)
-    message = libsrvr.Message(sel, conn, addr)
-    sel.register(conn, selectors.EVENT_READ, data=message)
-
-
-def main():
-
-    if len(sys.argv) != 3:
-        print(f"usage: {sys.argv[0]} <host> <port>")
-        sys.exit(1)
-
-    host, port = sys.argv[1], int(sys.argv[2])
-    lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-    # Avoid bind() exception: OSError: [Errno 48] Address already in use
-    lsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
-    lsock.bind((host, port))
-    lsock.listen()
-    print(f"listening on {(host, port)}")
-    lsock.setblocking(False)
-    sel.register(lsock, selectors.EVENT_READ, data=None)
-
-    try:
-        while True:
-            events = sel.select(timeout=None)
-            for key, mask in events:
-                if key.data is None:
-                    accept_wrapper(key.fileobj)
-                else:
-                    message = key.data
-                    try:
-                        message.process_events(mask)
-                    except Exception:
-                        print(
-                            f"main: Error: Exception for {message.addr}:\n"
-                            f"{traceback.format_exc()}"
-                        )
-                        message.close()
-    except KeyboardInterrupt:
-        print("caught keyboard interrupt, exiting")
-    finally:
-        sel.close()
-
-
-if __name__ == "__main__":
-    main()
diff --git a/python/socket/deneme.py b/python/socket/deneme.py
deleted file mode 100644
index 941146e..0000000
--- a/python/socket/deneme.py
+++ /dev/null
@@ -1,11 +0,0 @@
-import socket
-
-url = "www.google.com"
-
-try:
-    host_ip = socket.gethostbyname(url)
-except sockect.gaierror:
-    print("there was an error resolving the host")
-    sys.exit()
-
-print(f"{url} 's ip : {host_ip}")
diff --git a/python/socket/echo_clnt.py b/python/socket/echo_clnt.py
deleted file mode 100644
index 7fb1818..0000000
--- a/python/socket/echo_clnt.py
+++ /dev/null
@@ -1,12 +0,0 @@
-#!/usr/bin/env python3
-import socket
-HOST = "127.0.0.1"  # the server's hostname or IP address
-PORT = 5634  # the port used by the server
-
-with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
-    s.connect((HOST, PORT))
-    s.sendall(b"hello, universe.\nHi, friend.")
-    data = s.recv(1024)
-
-print(f"received some data:\n{data=}")
-print(f"rendered data :\n---\n{data.decode()}\n---")
diff --git a/python/socket/echo_srv.py b/python/socket/echo_srv.py
deleted file mode 100644
index f0c7d0f..0000000
--- a/python/socket/echo_srv.py
+++ /dev/null
@@ -1,17 +0,0 @@
-#!/usr/bin/env python3
-import socket
-
-HOST = "127.0.0.1"  # localhost or "127.0.0.1" (standart loopback interface address)
-PORT = 5634  # port to listen on (non-privileged ports are > 1023)
-
-with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
-    s.bind((HOST, PORT))
-    s.listen()
-    conn, addr = s.accept()
-    with conn:
-        print(f"connected by {addr} conn {conn=}")
-        while True:
-            data = conn.recv(1024)
-            if not data:
-                break
-            conn.sendall(data)
diff --git a/python/socket/libclnt.py b/python/socket/libclnt.py
deleted file mode 100644
index 7237cec..0000000
--- a/python/socket/libclnt.py
+++ /dev/null
@@ -1,198 +0,0 @@
-import sys
-import selectors
-import json
-import io
-import struct
-
-
-class Message:
-    def __init__(self, selector, sock, addr, request):
-        self.selector = selector
-        self.sock = sock
-        self.addr = addr
-        self.request = request
-        self._recv_buffer = b""
-        self._send_buffer = b""
-        self._request_queued = False
-        self._jsonheader_len = None
-        self.jsonheader = None
-        self.response = None
-
-    def _set_selector_events_mask(self, mode):
-        """Set selector to listen for events: mode is 'r', 'w', or 'rw'."""
-        if mode == "r":
-            events = selectors.EVENT_READ
-        elif mode == "w":
-            events = selectors.EVENT_WRITE
-        elif mode == "rw":
-            events = selectors.EVENT_READ | selectors.EVENT_WRITE
-        else:
-            raise ValueError(f"Invalid events mask mode {mode!r}.")
-        self.selector.modify(self.sock, events, data=self)
-
-    def _read(self):
-        try:
-            # Should be ready to read
-            data = self.sock.recv(4096)
-        except BlockingIOError:
-            # Resource temporarily unavailable (errno EWOULDBLOCK)
-            pass
-        else:
-            if data:
-                self._recv_buffer += data
-            else:
-                raise RuntimeError("Peer closed.")
-
-    def _write(self):
-        if self._send_buffer:
-            print(f"Sending {self._send_buffer!r} to {self.addr}")
-            try:
-                # Should be ready to write
-                sent = self.sock.send(self._send_buffer)
-            except BlockingIOError:
-                # Resource temporarily unavailable (errno EWOULDBLOCK)
-                pass
-            else:
-                self._send_buffer = self._send_buffer[sent:]
-
-    def _json_encode(self, obj, encoding):
-        return json.dumps(obj, ensure_ascii=False).encode(encoding)
-
-    def _json_decode(self, json_bytes, encoding):
-        tiow = io.TextIOWrapper(io.BytesIO(json_bytes), encoding=encoding, newline="")
-        obj = json.load(tiow)
-        tiow.close()
-        return obj
-
-    def _create_message(self, *, content_bytes, content_type, content_encoding):
-        jsonheader = {
-            "byteorder": sys.byteorder,
-            "content-type": content_type,
-            "content-encoding": content_encoding,
-            "content-length": len(content_bytes),
-        }
-        jsonheader_bytes = self._json_encode(jsonheader, "utf-8")
-        message_hdr = struct.pack(">H", len(jsonheader_bytes))
-        message = message_hdr + jsonheader_bytes + content_bytes
-        return message
-
-    def _process_response_json_content(self):
-        content = self.response
-        result = content.get("result")
-        print(f"Got result: {result}")
-
-    def _process_response_binary_content(self):
-        content = self.response
-        print(f"Got response: {content!r}")
-
-    def process_events(self, mask):
-        if mask & selectors.EVENT_READ:
-            self.read()
-        if mask & selectors.EVENT_WRITE:
-            self.write()
-
-    def read(self):
-        self._read()
-
-        if self._jsonheader_len is None:
-            self.process_protoheader()
-
-        if self._jsonheader_len is not None:
-            if self.jsonheader is None:
-                self.process_jsonheader()
-
-        if self.jsonheader:
-            if self.response is None:
-                self.process_response()
-
-    def write(self):
-        if not self._request_queued:
-            self.queue_request()
-
-        self._write()
-
-        if self._request_queued:
-            if not self._send_buffer:
-                # Set selector to listen for read events, we're done writing.
-                self._set_selector_events_mask("r")
-
-    def close(self):
-        print(f"Closing connection to {self.addr}")
-        try:
-            self.selector.unregister(self.sock)
-        except Exception as e:
-            print(f"Error: selector.unregister() exception for " f"{self.addr}: {e!r}")
-
-        try:
-            self.sock.close()
-        except OSError as e:
-            print(f"Error: socket.close() exception for {self.addr}: {e!r}")
-        finally:
-            # Delete reference to socket object for garbage collection
-            self.sock = None
-
-    def queue_request(self):
-        content = self.request["content"]
-        content_type = self.request["type"]
-        content_encoding = self.request["encoding"]
-        if content_type == "text/json":
-            req = {
-                "content_bytes": self._json_encode(content, content_encoding),
-                "content_type": content_type,
-                "content_encoding": content_encoding,
-            }
-        else:
-            req = {
-                "content_bytes": content,
-                "content_type": content_type,
-                "content_encoding": content_encoding,
-            }
-        message = self._create_message(**req)
-        self._send_buffer += message
-        self._request_queued = True
-
-    def process_protoheader(self):
-        hdrlen = 2
-        if len(self._recv_buffer) >= hdrlen:
-            self._jsonheader_len = struct.unpack(">H", self._recv_buffer[:hdrlen])[0]
-            self._recv_buffer = self._recv_buffer[hdrlen:]
-
-    def process_jsonheader(self):
-        hdrlen = self._jsonheader_len
-        if len(self._recv_buffer) >= hdrlen:
-            self.jsonheader = self._json_decode(self._recv_buffer[:hdrlen], "utf-8")
-            self._recv_buffer = self._recv_buffer[hdrlen:]
-            for reqhdr in (
-                "byteorder",
-                "content-length",
-                "content-type",
-                "content-encoding",
-            ):
-                if reqhdr not in self.jsonheader:
-                    raise ValueError(f"Missing required header '{reqhdr}'.")
-
-    def process_response(self):
-        content_len = self.jsonheader["content-length"]
-        if not len(self._recv_buffer) >= content_len:
-            return
-        data = self._recv_buffer[:content_len]
-        self._recv_buffer = self._recv_buffer[content_len:]
-        if self.jsonheader["content-type"] == "text/json":
-            encoding = self.jsonheader["content-encoding"]
-            self.response = self._json_decode(data, encoding)
-            print(f"Received response {self.response!r} from {self.addr}")
-            self._process_response_json_content()
-        else:
-            # Binary or unknown content-type
-            self.response = data
-            print(
-                f"Received {self.jsonheader['content-type']} "
-                f"response from {self.addr}"
-            )
-            self._process_response_binary_content()
-        # Close when response has been processed
-        self.close()
-
-
-if __name__ == "__main__":
-    print("this is lib file this file only contains classes and funcs/methods")
diff --git a/python/socket/libsrvr.py b/python/socket/libsrvr.py
deleted file mode 100644
index e569e9e..0000000
--- a/python/socket/libsrvr.py
+++ /dev/null
@@ -1,205 +0,0 @@
-import sys
-import selectors
-import json
-import io
-import struct
-
-request_search = {
-    "morpheus": "Follow the white rabbit. \U0001f430",
-    "ring": "In the caves beneath the Misty Mountains. \U0001f48d",
-    "\U0001f436": "\U0001f43e Playing ball! \U0001f3d0",
-}
-
-
-class Message:
-    def __init__(self, selector, sock, addr):
-        self.selector = selector
-        self.sock = sock
-        self.addr = addr
-        self._recv_buffer = b""
-        self._send_buffer = b""
-        self._jsonheader_len = None
-        self.jsonheader = None
-        self.request = None
-        self.response_created = False
-
-    def _set_selector_events_mask(self, mode):
-        """set selector to listen for events: mode is 'r', 'w', or 'rw'."""
-        if mode == "r":
-            events = selectors.EVENT_READ
-        elif mode == "w":
-            events = selectors.EVENT_WRITE
-        elif mode == "rw":
-            events = selectors.EVENT_READ | selectors.EVENT_WRITE
-        else:
-            raise ValueError(f"Invalid events mask mode {mode!r}.")
-        self.selector.modify(self.sock, events, data=self)
-
-    def _read(self):
-        try:
-            # Should be ready to read
-            data = self.sock.recv(4096)
-        except BlockingIOError:
-            # Resource temporarily unavailable (errno EWOULDBLOCK)
-            pass
-        else:
-            if data:
-                self._recv_buffer += data
-            else:
-                raise RuntimeError("Peer closed.")
-
-    def _write(self):
-        if self._send_buffer:
-            print(f"Sending {self._send_buffer!r} to {self.addr}")
-            try:
-                # Should be ready to write
-                sent = self.sock.send(self._send_buffer)
-            except BlockingIOError:
-                # Resource temporarily unavailable (errno EWOULDBLOCK)
-                pass
-            else:
-                self._send_buffer = self._send_buffer[sent:]
-                # Close when the buffer is drained. The response has been sent.
-                if sent and not self._send_buffer:
-                    self.close()
-
-    def _json_encode(self, obj, encoding):
-        return json.dumps(obj, ensure_ascii=False).encode(encoding)
-
-    def _json_decode(self, json_bytes, encoding):
-        tiow = io.TextIOWrapper(io.BytesIO(json_bytes), encoding=encoding, newline="")
-        obj = json.load(tiow)
-        tiow.close()
-        return obj
-
-    def _create_message(self, *, content_bytes, content_type, content_encoding):
-        jsonheader = {
-            "byteorder": sys.byteorder,
-            "content-type": content_type,
-            "content-encoding": content_encoding,
-            "content-length": len(content_bytes),
-        }
-        jsonheader_bytes = self._json_encode(jsonheader, "utf-8")
-        message_hdr = struct.pack(">H", len(jsonheader_bytes))
-        message = message_hdr + jsonheader_bytes + content_bytes
-        return message
-
-    def _create_response_json_content(self):
-        action = self.request.get("action")
-        if action == "search":
-            query = self.request.get("value")
-            answer = request_search.get(query) or f"No match for '{query}'."
-            content = {"result": answer}
-        else:
-            content = {"result": f"Error: invalid action '{action}'."}
-        content_encoding = "utf-8"
-        response = {
-            "content_bytes": self._json_encode(content, content_encoding),
-            "content_type": "text/json",
-            "content_encoding": content_encoding,
-        }
-        return response
-
-    def _create_response_binary_content(self):
-        response = {
-            "content_bytes": b"First 10 bytes of request: " + self.request[:10],
-            "content_type": "binary/custom-server-binary-type",
-            "content_encoding": "binary",
-        }
-        return response
-
-    def process_events(self, mask):
-        if mask & selectors.EVENT_READ:
-            self.read()
-        if mask & selectors.EVENT_WRITE:
-            self.write()
-
-    def read(self):
-        self._read()
-
-        if self._jsonheader_len is None:
-            self.process_protoheader()
-
-        if self._jsonheader_len is not None:
-            if self.jsonheader is None:
-                self.process_jsonheader()
-
-        if self.jsonheader:
-            if self.request is None:
-                self.process_request()
-
-    def write(self):
-        if self.request:
-            if not self.response_created:
-                self.create_response()
-
-        self._write()
-
-    def close(self):
-        print(f"closing connection to {self.addr}")
-        try:
-            self.selector.unregister(self.sock)
-        except Exception as e:
-            print(f"error: selector.unregister() exception for " f"{self.addr}: {e!r}")
-
-        try:
-            self.sock.close()
-        except OSError as e:
-            print(f"error: socket.close() exception for {self.addr}: {e!r}")
-        finally:
-            # Delete reference to socket object for garbage collection
-            self.sock = None
-
-    def process_protoheader(self):
-        hdrlen = 2
-        if len(self._recv_buffer) >= hdrlen:
-            self._jsonheader_len = struct.unpack(">H", self._recv_buffer[:hdrlen])[0]
-            self._recv_buffer = self._recv_buffer[hdrlen:]
-
-    def process_jsonheader(self):
-        hdrlen = self._jsonheader_len
-        if len(self._recv_buffer) >= hdrlen:
-            self.jsonheader = self._json_decode(self._recv_buffer[:hdrlen], "utf-8")
-            self._recv_buffer = self._recv_buffer[hdrlen:]
-            for reqhdr in (
-                "byteorder",
-                "content-length",
-                "content-type",
-                "content-encoding",
-            ):
-                if reqhdr not in self.jsonheader:
-                    raise ValueError(f"missing required header '{reqhdr}'.")
-
-    def process_request(self):
-        content_len = self.jsonheader["content-length"]
-        if not len(self._recv_buffer) >= content_len:
-            return
-        data = self._recv_buffer[:content_len]
-        self._recv_buffer = self._recv_buffer[content_len:]
-        if self.jsonheader["content-type"] == "text/json":
-            encoding = self.jsonheader["content-encoding"]
-            self.request = self._json_decode(data, encoding)
-            print(f"received request {self.request!r} from {self.addr}")
-        else:
-            # Binary or unknown content-type
-            self.request = data
-            print(
-                f"received {self.jsonheader['content-type']} "
-                f"request from {self.addr}"
-            )
-        # Set selector to listen for write events, we're done reading.
-        self._set_selector_events_mask("w")
-
-    def create_response(self):
-        if self.jsonheader["content-type"] == "text/json":
-            response = self._create_response_json_content()
-        else:
-            # Binary or unknown content-type
-            response = self._create_response_binary_content()
-        message = self._create_message(**response)
-        self.response_created = True
-        self._send_buffer += message
-
-
-if __name__ == "__main__":
-    print("this is lib file this file only contains classes and funcs/methods")
diff --git a/python/socket/multiconn-clnt.py b/python/socket/multiconn-clnt.py
deleted file mode 100644
index 143d247..0000000
--- a/python/socket/multiconn-clnt.py
+++ /dev/null
@@ -1,73 +0,0 @@
-#!/usr/bin/env python3
-import sys
-import socket
-import selectors
-import types
-
-sel = selectors.DefaultSelector()
-messages = [b"hello message 1 from client.", b"hi message 2 from client."]
-
-def start_connections(host, port, num_conns):
-    server_addr = (host, port)
-    for i in range(0, num_conns):
-        connid = i + 1
-        print(f"starting connection {connid} to {server_addr}")
-        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-        sock.setblocking(False)
-        sock.connect_ex(server_addr)
-        events = selectors.EVENT_READ | selectors.EVENT_WRITE
-        data = types.SimpleNamespace(
-            connid=connid,
-            msg_total=sum(len(m) for m in messages),
-            recv_total=0,
-            messages=messages.copy(),
-            outb=b"",
-        )
-        sel.register(sock, events, data=data)
-
-
-def service_connection(key, mask):
-    sock = key.fileobj
-    data = key.data
-    if mask & selectors.EVENT_READ:
-        recv_data = sock.recv(1024)  # should be ready to read
-        if recv_data:
-            print(f"received {recv_data!r} from connection {data.connid}")
-            data.recv_total += len(recv_data)
-        if not recv_data or data.recv_total == data.msg_total:
-            print(f"closing connection {data.connid}")
-            sel.unregister(sock)
-            sock.close()
-    if mask & selectors.EVENT_WRITE:
-        if not data.outb and data.messages:
-            data.outb = data.messages.pop(0)
-        if data.outb:
-            print(f"sending {data.outb!r} to connection {data.connid}")
-            sent = sock.send(data.outb)  # should be ready to write
-            data.outb = data.outb[sent:]
-
-
-if len(sys.argv) != 4:
-    print(f"usage: {sys.argv[0]} <host> <port> <num_connections> in example:\n {sys.argv[0]} 127.0.0.1 5634 2")
-    sys.exit(1)
-
-def main():
-    host, port, num_conns = sys.argv[1:4]
-    start_connections(host, int(port), int(num_conns))
-
-    try:
-        while True:
-            events = sel.select(timeout=1)
-            if events:
-                for key, mask in events:
-                    service_connection(key, mask)
-            # check for a socket being monitored to continue.
-            if not sel.get_map():
-                break
-    except KeyboardInterrupt:
-        print("caught keyboard interrupt, exiting ...")
-    finally:
-        sel.close()
-
-if __name__ == '__main__':
-    main()
diff --git a/python/socket/mutliconn-srvr.py b/python/socket/mutliconn-srvr.py
deleted file mode 100644
index 1db2186..0000000
--- a/python/socket/mutliconn-srvr.py
+++ /dev/null
@@ -1,69 +0,0 @@
-#!/usr/bin/env python3
-import sys
-import socket
-import selectors
-import types
-
-
-sel = selectors.DefaultSelector()
-
-
-def accept_wrapper(sock):
-    conn, addr = sock.accept()  # should be ready to read
-    print(f"accepted connection from {addr}")
-    conn.setblocking(False)
-    data = types.SimpleNamespace(addr=addr, inb=b"", outb=b"")
-    events = selectors.EVENT_READ | selectors.EVENT_WRITE
-    sel.register(conn, events, data=data)
-
-
-def service_connection(key, mask):
-    sock = key.fileobj
-    data = key.data
-    if mask & selectors.EVENT_READ:
-        recv_data = sock.recv(1024)  # Should be ready to read
-        if recv_data:
-            data.outb += recv_data
-        else:
-            print(f"closing connection to {data.addr}")
-            sel.unregister(sock)
-            sock.close()
-    if mask & selectors.EVENT_WRITE:
-        if data.outb:
-            print(f"echoing {data.outb!r} to {data.addr}")
-            sent = sock.send(data.outb)  # Should be ready to write
-            data.outb = data.outb[sent:]
-
-
-def main():
-
-    if len(sys.argv) < 2:
-        raise Exception(
-            f'you are not give me correct args\n args must be <host> and <port> example:\n python {__file__.split("/")[-1]} <HOST> <PORT>\n ./{__file__.split("/")[-1]} <HOST> <PORT>\n ./{__file__.split("/")[-1]} 127.0.0.1 5634'
-        )
-
-    host, port = sys.argv[1], int(sys.argv[2])
-
-    lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-    lsock.bind((host, port))
-    lsock.listen()
-    print(f"listenin on host: {host} port: {port} ")
-    lsock.setblocking(False)
-    sel.register(lsock, selectors.EVENT_READ, data=None)
-
-    try:
-        while True:
-            events = sel.select(timeout=None)
-            for key, mask in events:
-                if key.data is None:
-                    accept_wrapper(key.fileobj)
-                else:
-                    service_connection(key, mask)
-    except KeyboardInterrupt:
-        print("Caught keyboard interrupt, exiting")
-    finally:
-        sel.close()
-
-
-if __name__ == "__main__":
-    main()
diff --git a/python/socket/readme.org b/python/socket/readme.org
deleted file mode 100644
index a2acc90..0000000
--- a/python/socket/readme.org
+++ /dev/null
@@ -1,1116 +0,0 @@
-#+title: basics of python standard library module *socket*
-#+author: mal1kc
-#+options: toc:3
-
-* what is *sockets* why we use them
-
-sockets and the socket API are  used to send messages over a network.They provide form of inter-process communication (IPC).The network can be logical, local network to computer, or one that's physically connected to an external network.The most obvious example is Internet.
-
-first their use was ARPANET in 1971 and then become API in Berkeley Software Distribution (BSD) operating system in 1983 called Berkeley Sockets
-
-[[https://en.wikipedia.org/wiki/Berkeley_sockets?oldformat=true][read more about Berkeley sockets (commonly implemented socket API)]]
-
-* what it is *socket* module
-
-#+begin_quote
-This module provides access to the BSD socket interface. It is available on all modern Unix systems, Windows, Mac-OS, and probably additional platforms.
-#+end_quote
--- [[https://docs.python.org/3/library/socket.html][python org module]]
-
-** the primary socket API functions and methods in this module are:
-
-+ socket _class_
-  - .bind()
-  - .listen()
-  - .accept()
-  - .connect()
-  - .connect_ex()
-  - .send()
-  - .recv()
-  - .close()
-
-python provides good API that maps directly to syscalls,
-their ~C~ counterparts.
-
-as part of its ~std~ library, python has classes that make using these lower level socket operations easier.
-
-* tcp sockets
-
-when we create socket object using *socket.socket()*,specify socket type as socket.SOCK_STREAM.When we do that, the default protocol that's used is the [[https://en.wikipedia.org/wiki/Transmission_Control_Protocol][Transmission Control Protocol a.k.a. TCP]] . this is default and this is probably what we want.
-
-if we want a lookout there was a [[https://commons.wikimedia.org/wiki/File:InternetSocketBasicDiagram_zhtw.png][socket diagram (basically tells how tcp works)]]
-
-* some example echo server,client
-** src of echo server
-
-#+begin_src python :tangle echo_srv.py :shebang "#!/usr/bin/env python3"
-import socket
-
-HOST = "127.0.0.1"  # localhost or "127.0.0.1" (standard loopback interface address)
-PORT = 5634  # port to listen on (non-privileged ports are > 1023)
-
-with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
-    s.bind((HOST, PORT))
-    s.listen()
-    conn, addr = s.accept()
-    with conn:
-        print(f"connected by {addr} conn {conn=}")
-        while True:
-            data = conn.recv(1024)
-            if not data:
-                break
-            conn.sendall(data)
-#+end_src
-
-**** explanation of server
-
-- we create socket object with  [[https://docs.python.org/3/reference/datamodel.html#context-managers][context manager type]] ,by doing that after a with indent code finishes it automatically calls ~s.close()~
-- the args of socket objects are
-  + *AF_INET* : IPV4
-  + *SOCK_STREAM* : TCP
-- ~s.bind()~ is binds our socket to given HOST and PORT
-- ~s.listen()~ Enable a server to accept connections. If backlog is specified, it must be at least 0 (if it is lower, it is set to 0); it specifies the number of unaccepted connections that the system will allow before refusing new connections. If not specified, a default reasonable value is chosen.
-- ~s.accept()~ blocks execution and waits for incoming connection.when client connects it returns a new socket object representing connection and a tuple about client address ( ipv4 (host, port) , ipv6 (host, port, flow-info, scope id) [[https://docs.python.org/3/library/socket.html#socket-families][(more info socket add families]] ) .
-- after ~.accept()~ provide connection socket object,an while loop is used to loop over blocking calls to ~conn.recv()~.This reads whatever data the client sends and echoes t it back using conn.sendall().
-- if conn.recv() returns empty *bytes* object,b'',that signals client closed the connection and the loop is terminated
-
-** src of echo client
-
-#+begin_src python :tangle echo_clnt.py :shebang "#!/usr/bin/env python3"
-import socket
-HOST = "127.0.0.1"  # the server's hostname or IP address
-PORT = 5634  # the port used by the server
-
-with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
-    s.connect((HOST, PORT))
-    s.sendall(b"hello, universe.\nHi, friend.")
-    data = s.recv(1024)
-
-print(f"received some data:\n{data=}")
-print(f"rendered data :\n---\n{data.decode()}\n---")
-#+end_src
-
-
-* handling multiple connections
-
-the echo server has its limitations.one of big ones is that is serves only one client then exists.the echo client has some limitations too,but there is a extra problem.when client uses ~s.recv()~, *it's possible that it will return only one byte,b'h' from b'hello, universe'*
-
-the buffsize arg of 1024 used above is the maximum amount of data to be received at once.it doesn't mean that ~.recv()~ will return 1024 bytes.
-
-the ~.send()~ method also behaves this way.it returns the number of bytes sent, which may be less than the size of data passed in.we are responsible for checking this and calling ~.send()~ as many times as needed to send all of the data.
-
-#+begin_quote
-Returns the number of bytes sent. Applications are responsible for checking that all data has been sent; if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. For further information on this topic, consult the [[https://docs.python.org/3/howto/sockets.html#socket-howto][Socket Programming HOWTO]].
-#+end_quote
--- [[https://docs.python.org/3/library/socket.html#socket.socket.send][python.org source]]
-
-in the example ~echo client~ we avoided having to do this by using ~.sendall()~
-
-#+begin_quote
-Unlike ~send()~, this method continues to send data from bytes until either all data has been sent or an error occurs. None is returned on success. On error, an exception is raised, and there is no way to determine how much data, if any, was successfully sent.
-#+end_quote
--- [[https://docs.python.org/3/library/socket.html#socket.socket.sendall][python.org source]]
-
-+ we have two problems at this point
-
-  - how do we handle multiple connections
-
-  - we need to call ~.send()~ and ~.recv()~ until all data is sent or received.
-
-there are many approaches to [[https://realpython.com/python-concurrency/][concurrency]],there was std library module ~asyncio~ (after python 3.4),there was std library module ~threads~.
-
-the trouble with concurrency there are many subtleties to consider and guard against.but simplicity for examples of ~socket~ module we are going to use something traditional.we're going to use [[https://docs.python.org/3/library/selectors.html#selectors.BaseSelector.select][.select()]].
-
-the ~.select()~ method allows we to check for I/O completion on more than one socket.so new can call ~.select()~ to see which socket have I/O ready for reading and/or writing.but in python there's more we use [[https://docs.python.org/3/library/selectors.html][selectors module]] in standard library so that the most beneficent implementation is used, regardless of OS (operating system).
-
-#+begin_quote
-This module (~selectors module~) allows high-level and efficient I/O multiplexing, built upon the select module primitives. Users are encouraged to use this module instead, unless they want precise control over the OS-level primitives used.
-#+end_quote
--- [[https://docs.python.org/3/library/selectors.html][High-level I/O multiplexing - source]]
-
-still,by using ~.select()~, we're not exactly to run concurrently.it still depends our workload,what our application needs,how many clients ,how many data transfer happens etc.
-
-** code with explanation of multiconnection server
-
-#+begin_src python
-import sys
-import socket
-import selectors
-import types
-
-sel = selectors.DefaultSelector()
-
-...
-
-if len(sys.argv) < 2:
-    raise Exception(
-        f'you are not give me correct args\n args must be host and port example:\n python {__file__.split("/")[-1]} HOST PORT\n ./{__file__.split("/")[-1]} HOST PORT\n ./{__file__.split("/")[-1]} 127.0.0.1 5634'
-    )
-
-
-host, port = sys.argv[1], int(sys.argv[2])
-
-lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-lsock.bind((host, port))
-lsock.listen()
-print(f"listenin on host: {host} port: {port} ")
-lsock.setblocking(False)
-sel.register(lsock, selectors.EVENT_READ, data=None)
-#+end_src
-
-- the biggest difference between ~echo server~ and this server is the call to ~lsock.setblocking(False)~ to configure socket in *non-blocking* mode. calls made to this socket will no longer block.when it's used with ~sel.select()~,we can wait for events on one or more sockets then read and write data when it's ready.
-
-- sel.register() registers the socket to be monitored with ~sel.select()~ for the events we're interested in (in this example EVENT_READ).
-
-- to store arbitrary data we'd like along with socket,we'll use ~data~.it's returned when ~.select()~ returns.we'll use data to keep track of what's been sent and received on the socket.
-
-#+begin_src python
-try:
-    while True:
-        events = sel.select(timeout=None)
-        for key, mask in events:
-            if key.data is None:
-                accept_wrapper(key.fileObj)
-            else:
-                service_connection(key,mask)
-except KeyboardInterrupt:
-    print('caught keyboard interrupt, exiting ...')
-finally:
-    sel.close()
-#+end_src
-
-- ~sel.select(timeout=None)~ blocks until there are sockets ready for I/O. it *returns a list of tuples, one for each socket*.Each tuple *contains a key and a mask*.The key is a [[https://docs.python.org/3/library/selectors.html#selectors.SelectorKey][SelectorKey -> namedtuple]] that contains a ~fileobj~ attribute key. *fileobj is socket object*, and mask is an event [[https://en.wikipedia.org/wiki/Mask_(computing)][mask]] of the operations that are ready.
-
-- if key.data is None,then we know it's from the listening socket and we need to accept the connection.we'll call our own ~accept_wrapper()~ function to get the new socket object and register it with the selector.we'll look at that in a moment.
-
-- if key.data is not None,then we know it's a client socket that's already been accepted, and we need to service it . ~service_connection()~ is then called with key and mask as arguments, and that's everything we need to operate on the socket.
-
-#+begin_src python
-def accept_wrapper(sock):
-    conn, addr = sock.accept()  # should be ready to read
-    print(f"accepted connection from {addr}")
-    conn.setblocking(False)
-    data = types.SimpleNamespace(addr=addr, inb=b"", outb=b"")
-    events = selectors.EVENT_READ | selectors.EVENT_WRITE
-    sel.register(conn, events, data=data)
-
-#+end_src
-
-- because the listening socket registered for the event selectors. ~EVENT_READ~, it should be ready to read. we call ~sock.accept()~ and then call ~conn.setblocking(False)~ to put the socket in non-blocking mode.
-
-- *remember* , this is the main objective in this version of the server because we don't want it to block.if it blocks, then the entire server is stalled until it returns.that means other sockects are left waiting event though the server isn't actively working. *this is the dreaded "hanging" state that we don't want our server to be in.*
-
-- next, we create an object to hold the data that we want included along with the socket using a [[https://docs.python.org/3/library/types.html#types.SimpleNamespace][SimpleNamespace]] , because we want to know when the client connection is ready for reading and writing,both of those events the client connections ready for reading and writing, both of those events are set with *bitwise OR* operators
-
-#+begin_src python
-
-
-def service_connection(key, mask):
-    sock = key.fileobj
-    data = key.data
-    if mask & selectors.EVENT_READ:
-        recv_data = sock.recv(1024)  # should be ready to read
-        if recv_data:
-            data.outb += recv_data
-        else:
-            print(f"closing connection to {data.addr}")
-            sel.unregister(sock)
-            sock.close()
-    if mask & selectors.EVENT_WRITE:
-        if data.outb:
-            print(f"echoing {data.outb!r} to {data.addr}")
-            sent = sock.send(data.outb)  # should be ready to write
-            data.outb = data.outb[sent:]
-
-#+end_src
-
-_this is heart of simple multi-connection server._
-
-- if  the socket is ready for reading,then ~mask & selectors.EVENT_READ~ will evaluate to True, so ~sock.recv()~ is called.Any data that's read is appended to ~data.outb~ so that can be sent later.
-
-- if no data is received, this means that the client has closed their socket,so the server should too. but *don’t forget* to call ~sel.unregister()~ before closing, so it’s no longer monitored by ~.select()~.
-
-- when the socket is ready for writing, which should always be the case for a healthy socket, any received data stored in ~data.outb~ is echoed to the client using ~socket.send()~. the bytes sent are then removed from send buffer.
-
-- the ~.send()~ method returns the number of bytes sent. this number can then be used with [[https://docs.python.org/3/reference/expressions.html#slicings][slice notation]]
-
-
-
-** code with explanation of multiconnection client
-
-#+begin_src python
-
-import sys
-import socket
-import selectors
-import types
-
-sel = selectors.DefaultSelector()
-messages = [b"hello message 1 from client.", b"hi message 2 from client."]
-
-def start_connections(host, port, num_conns):
-    server_addr = (host, port)
-    for i in range(0, num_conns):
-        connid = i + 1
-        print(f"starting connection {connid} to {server_addr}")
-        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-        sock.setblocking(False)
-        sock.connect_ex(server_addr)
-        events = selectors.EVENT_READ | selectors.EVENT_WRITE
-        data = types.SimpleNamespace(
-            connid=connid,
-            msg_total=sum(len(m) for m in messages),
-            recv_total=0,
-            messages=messages.copy(),
-            outb=b"",
-        )
-        sel.register(sock, events, data=data)
-
-#+end_src
-
-- ~num_conns~ is  read from the command-line and is the number of connections to create to the server.just like server, each socket is set to non-blocking mode.
-
-- we use [[https://docs.python.org/3/library/socket.html#socket.socket.connect_ex][.connect_ex()]] instead of ~.connect()~ because ~.connect()~ would immediately raise a BlockingIOError exception.The ~.connect_ex()~  method initially returns an /error indicator, errno.EINPROGRESS/ , instead of raising an exception that would interfere with the connection in progress. Once the connection is completed, the socket is ready for reading and writing and is returned by ~.select()~.
-
-- after the socket is set up, the data we want to store with the socket is created using ~SimpleNamespace~. the messages that client will send to server are copied using ~.copy()~ because each connection will call ~socket.send()~ and modify the list.everything needed to keep track of what the client needs to send, has sent, and has received, including total number of bytes in the messages, is stored in object data.
-
-  ~service_connection() for the client~
-
- #+begin_src python
-
-def service_connection(key, mask):
-    sock = key.fileobj
-    data = key.data
-    if mask & selectors.EVENT_READ:
-        recv_data = sock.recv(1024)  # should be ready to read
-        if recv_data:
-            print(f"received {recv_data!r} from connection {data.connid}")
-            data.recv_total += len(recv_data)
-        if not recv_data or data.recv_total == data.msg_total:
-            print(f"closing connection {data.connid}")
-            sel.unregister(sock)
-            sock.close()
-    if mask & selectors.EVENT_WRITE:
-        if not data.outb and data.messages:
-            data.outb = data.messages.pop(0)
-        if data.outb:
-            print(f"sending {data.outb!r} to connection {data.connid}")
-            sent = sock.send(data.outb)  # should be ready to write
-            data.outb = data.outb[sent:]
-
- #+end_src
-** src of multiconnection server
-
-#+begin_src python :tangle mutliconn-srvr.py :shebang "#!/usr/bin/env python3"
-import sys
-import socket
-import selectors
-import types
-
-
-sel = selectors.DefaultSelector()
-
-
-def accept_wrapper(sock):
-    conn, addr = sock.accept()  # should be ready to read
-    print(f"accepted connection from {addr}")
-    conn.setblocking(False)
-    data = types.SimpleNamespace(addr=addr, inb=b"", outb=b"")
-    events = selectors.EVENT_READ | selectors.EVENT_WRITE
-    sel.register(conn, events, data=data)
-
-
-def service_connection(key, mask):
-    sock = key.fileobj
-    data = key.data
-    if mask & selectors.EVENT_READ:
-        recv_data = sock.recv(1024)  # Should be ready to read
-        if recv_data:
-            data.outb += recv_data
-        else:
-            print(f"closing connection to {data.addr}")
-            sel.unregister(sock)
-            sock.close()
-    if mask & selectors.EVENT_WRITE:
-        if data.outb:
-            print(f"echoing {data.outb!r} to {data.addr}")
-            sent = sock.send(data.outb)  # Should be ready to write
-            data.outb = data.outb[sent:]
-
-
-def main():
-
-    if len(sys.argv) < 2:
-        raise Exception(
-            f'you are not give me correct args\n args must be <host> and <port> example:\n python {__file__.split("/")[-1]} <HOST> <PORT>\n ./{__file__.split("/")[-1]} <HOST> <PORT>\n ./{__file__.split("/")[-1]} 127.0.0.1 5634'
-        )
-
-    host, port = sys.argv[1], int(sys.argv[2])
-
-    lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-    lsock.bind((host, port))
-    lsock.listen()
-    print(f"listenin on host: {host} port: {port} ")
-    lsock.setblocking(False)
-    sel.register(lsock, selectors.EVENT_READ, data=None)
-
-    try:
-        while True:
-            events = sel.select(timeout=None)
-            for key, mask in events:
-                if key.data is None:
-                    accept_wrapper(key.fileobj)
-                else:
-                    service_connection(key, mask)
-    except KeyboardInterrupt:
-        print("Caught keyboard interrupt, exiting")
-    finally:
-        sel.close()
-
-
-if __name__ == "__main__":
-    main()
-#+end_src
-
-** src of multiconnection client
-
-#+begin_src python :tangle multiconn-clnt.py :shebang "#!/usr/bin/env python3"
-import sys
-import socket
-import selectors
-import types
-
-sel = selectors.DefaultSelector()
-messages = [b"hello message 1 from client.", b"hi message 2 from client."]
-
-def start_connections(host, port, num_conns):
-    server_addr = (host, port)
-    for i in range(0, num_conns):
-        connid = i + 1
-        print(f"starting connection {connid} to {server_addr}")
-        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-        sock.setblocking(False)
-        sock.connect_ex(server_addr)
-        events = selectors.EVENT_READ | selectors.EVENT_WRITE
-        data = types.SimpleNamespace(
-            connid=connid,
-            msg_total=sum(len(m) for m in messages),
-            recv_total=0,
-            messages=messages.copy(),
-            outb=b"",
-        )
-        sel.register(sock, events, data=data)
-
-
-def service_connection(key, mask):
-    sock = key.fileobj
-    data = key.data
-    if mask & selectors.EVENT_READ:
-        recv_data = sock.recv(1024)  # should be ready to read
-        if recv_data:
-            print(f"received {recv_data!r} from connection {data.connid}")
-            data.recv_total += len(recv_data)
-        if not recv_data or data.recv_total == data.msg_total:
-            print(f"closing connection {data.connid}")
-            sel.unregister(sock)
-            sock.close()
-    if mask & selectors.EVENT_WRITE:
-        if not data.outb and data.messages:
-            data.outb = data.messages.pop(0)
-        if data.outb:
-            print(f"sending {data.outb!r} to connection {data.connid}")
-            sent = sock.send(data.outb)  # should be ready to write
-            data.outb = data.outb[sent:]
-
-
-if len(sys.argv) != 4:
-    print(f"usage: {sys.argv[0]} <host> <port> <num_connections> in example:\n {sys.argv[0]} 127.0.0.1 5634 2")
-    sys.exit(1)
-
-def main():
-    host, port, num_conns = sys.argv[1:4]
-    start_connections(host, int(port), int(num_conns))
-
-    try:
-        while True:
-            events = sel.select(timeout=1)
-            if events:
-                for key, mask in events:
-                    service_connection(key, mask)
-            # check for a socket being monitored to continue.
-            if not sel.get_map():
-                break
-    except KeyboardInterrupt:
-        print("caught keyboard interrupt, exiting ...")
-    finally:
-        sel.close()
-
-if __name__ == '__main__':
-    main()
-
-#+end_src
-
-* application client and server  (more advanced example of mutliconn, less explained code):
-
-we want a client and server that handle errors appropriately so that other connections aren't effected.
-
-#+begin_quote
-All errors raise exceptions. The normal exceptions for invalid argument types and out-of-memory conditions can be raised. Errors related to socket or address semantics raise [[https://docs.python.org/3/library/exceptions.html#OSError][OSError]] or one of its subclasses.
-#+end_quote
--- [[https://docs.python.org/3/library/socket.html][source]]
-
-so, one thing we need to catch ~OSError~.Another important consideration in relation to errors is *timeout*.
-*timeouts* are cause a lot of trouble; hosts and routers are rebooted, switch ports go bad, cables go bad, cables get unplugged.best way to handle them is prevent them.
-
-when we use TCP we read data from continues stream from network. however, unlike reading a file, there's no [[https://docs.python.org/3/tutorial/inputoutput.html#methods-of-file-objects][f.seek()]].
-
-once we've read them,they need to be saved somewhere, or else we will have dropped them. calling ~.recv()~ again reads the next stream of bytes available from socket.
-
-we'll be reading from the socket in chunks. so, we need to call ~.recv()~ and save the data in a buffer until we've read enough bytes to have a complete message that makes sens to our application.
-
-in other words,we need to keep up with how many bytes read, and figure out where the messages boundaries are.
-
-one of solution of this is send always fixed size data.but it's insufficient for most ways.
-
-we'll learn a generic approach, one that's used by many protocols,including HTTP.we'll prefix messages with a *header* that includes content length as well as any other fields we need.by doing this,we'll only need to keep up with the header.Once we’ve read the header, we can process it to determine the length of the message’s content. With the content length, we can then read that number of bytes to consume it.
-
-we'll implement this by creating a custom class that can send and receive messages that contain text or binary data.
-
-before we get started,we need to learn something.in earlier examples we're sending and receiving raw bytes.if we receive data and want to use it in a context where it's interpreted as multiple bytes, for example a 4-byte integer,we'll need to take int o account that it could be in a format that's not native to our machine's CPU.The client or server on the other end could have a CPU that uses a different byte order than our own.if this is the case, then we'll need to convert it to our host's native byte order before using it. this byte order referred to as a CPU's [[https://en.wikipedia.org/wiki/Endianness][sandiness]].
-
-we'll avoid this issue by takin advantage of Unicode for our message header and using the encoding UTF-8.since UTF-8 uses an 8-bit encoding, there are no byte ordering issues.
-
-by the way we can easily determine the byte code of our machine by using ~sys.byteorder~
-
-#+begin_src shell
-python -c 'import sys; print(repr(sys.byteorder))'
-#+end_src
-
-#+RESULTS:
-: 'little'
-
-** application protocol header
-
-the app protocol header is:
-
-- variable-length text
-- unicode with encoding UTF-8
-- a python dict serialize by using [[https://docs.python.org/3/library/json.html][JSON]]
-
-| name             | desc                                                                                           |
-| byteorder        | the byte order of the machine (uses sys.byteorder).this may not required by every application. |
-| content-length   | the length of content in bytes.                                                                |
-| content-type     | type of content in payload (text/json,binary/binary-type)                                      |
-| content-encoding | the encoding used by the content (utf-8,binary)                                                |
-
-** sending an  app message
-
-we have still some problem. we have a variable-length header,nice and flexible,but how do we know the length of the header when reading it with ~.recv()~?
-
-when we previously learned about using ~.recv()~ and message boundaries, we also learned that fixed length can be inefficient. that's true,but we're going to use a small,2-byte,fixed-length header to prefix the JSON header that contains its length.
-
-** application message class
-
-to keep things simple but still demonstrate how things work in real world applications, this example uses an application protocol that implements a basic search feature. the client sens aa search request and the server does a lookup for a match if the request sent by the client isn't recognized as a search, the server assumes it's a binary request and returns a binary response.
-
-general work steps like this:
-
-| step | endpoint | action / message content                       |
-|    1 | client   | sends a message containing request content     |
-|    2 | server   | receives and processes client request message  |
-|    3 | server   | sends a message containing response content    |
-|    4 | client   | receives and processes server response message |
-
-file layout
-
-| app    | file        | code                        |
-| server | app-srvr.py | the servers's main coode    |
-| server | libsrvr.py  | the servers's message class |
-| client | app-clnt.py | the client's main code      |
-| client | libclnt.py  | the client's message class  |
-
-*** src of lib server
-
-#+begin_src python :tangle libsrvr.py
-import sys
-import selectors
-import json
-import io
-import struct
-
-request_search = {
-    "morpheus": "Follow the white rabbit. \U0001f430",
-    "ring": "In the caves beneath the Misty Mountains. \U0001f48d",
-    "\U0001f436": "\U0001f43e Playing ball! \U0001f3d0",
-}
-
-
-class Message:
-    def __init__(self, selector, sock, addr):
-        self.selector = selector
-        self.sock = sock
-        self.addr = addr
-        self._recv_buffer = b""
-        self._send_buffer = b""
-        self._jsonheader_len = None
-        self.jsonheader = None
-        self.request = None
-        self.response_created = False
-
-    def _set_selector_events_mask(self, mode):
-        """set selector to listen for events: mode is 'r', 'w', or 'rw'."""
-        if mode == "r":
-            events = selectors.EVENT_READ
-        elif mode == "w":
-            events = selectors.EVENT_WRITE
-        elif mode == "rw":
-            events = selectors.EVENT_READ | selectors.EVENT_WRITE
-        else:
-            raise ValueError(f"Invalid events mask mode {mode!r}.")
-        self.selector.modify(self.sock, events, data=self)
-
-    def _read(self):
-        try:
-            # Should be ready to read
-            data = self.sock.recv(4096)
-        except BlockingIOError:
-            # Resource temporarily unavailable (errno EWOULDBLOCK)
-            pass
-        else:
-            if data:
-                self._recv_buffer += data
-            else:
-                raise RuntimeError("Peer closed.")
-
-    def _write(self):
-        if self._send_buffer:
-            print(f"Sending {self._send_buffer!r} to {self.addr}")
-            try:
-                # Should be ready to write
-                sent = self.sock.send(self._send_buffer)
-            except BlockingIOError:
-                # Resource temporarily unavailable (errno EWOULDBLOCK)
-                pass
-            else:
-                self._send_buffer = self._send_buffer[sent:]
-                # Close when the buffer is drained. The response has been sent.
-                if sent and not self._send_buffer:
-                    self.close()
-
-    def _json_encode(self, obj, encoding):
-        return json.dumps(obj, ensure_ascii=False).encode(encoding)
-
-    def _json_decode(self, json_bytes, encoding):
-        tiow = io.TextIOWrapper(io.BytesIO(json_bytes), encoding=encoding, newline="")
-        obj = json.load(tiow)
-        tiow.close()
-        return obj
-
-    def _create_message(self, *, content_bytes, content_type, content_encoding):
-        jsonheader = {
-            "byteorder": sys.byteorder,
-            "content-type": content_type,
-            "content-encoding": content_encoding,
-            "content-length": len(content_bytes),
-        }
-        jsonheader_bytes = self._json_encode(jsonheader, "utf-8")
-        message_hdr = struct.pack(">H", len(jsonheader_bytes))
-        message = message_hdr + jsonheader_bytes + content_bytes
-        return message
-
-    def _create_response_json_content(self):
-        action = self.request.get("action")
-        if action == "search":
-            query = self.request.get("value")
-            answer = request_search.get(query) or f"No match for '{query}'."
-            content = {"result": answer}
-        else:
-            content = {"result": f"Error: invalid action '{action}'."}
-        content_encoding = "utf-8"
-        response = {
-            "content_bytes": self._json_encode(content, content_encoding),
-            "content_type": "text/json",
-            "content_encoding": content_encoding,
-        }
-        return response
-
-    def _create_response_binary_content(self):
-        response = {
-            "content_bytes": b"First 10 bytes of request: " + self.request[:10],
-            "content_type": "binary/custom-server-binary-type",
-            "content_encoding": "binary",
-        }
-        return response
-
-    def process_events(self, mask):
-        if mask & selectors.EVENT_READ:
-            self.read()
-        if mask & selectors.EVENT_WRITE:
-            self.write()
-
-    def read(self):
-        self._read()
-
-        if self._jsonheader_len is None:
-            self.process_protoheader()
-
-        if self._jsonheader_len is not None:
-            if self.jsonheader is None:
-                self.process_jsonheader()
-
-        if self.jsonheader:
-            if self.request is None:
-                self.process_request()
-
-    def write(self):
-        if self.request:
-            if not self.response_created:
-                self.create_response()
-
-        self._write()
-
-    def close(self):
-        print(f"closing connection to {self.addr}")
-        try:
-            self.selector.unregister(self.sock)
-        except Exception as e:
-            print(f"error: selector.unregister() exception for " f"{self.addr}: {e!r}")
-
-        try:
-            self.sock.close()
-        except OSError as e:
-            print(f"error: socket.close() exception for {self.addr}: {e!r}")
-        finally:
-            # Delete reference to socket object for garbage collection
-            self.sock = None
-
-    def process_protoheader(self):
-        hdrlen = 2
-        if len(self._recv_buffer) >= hdrlen:
-            self._jsonheader_len = struct.unpack(">H", self._recv_buffer[:hdrlen])[0]
-            self._recv_buffer = self._recv_buffer[hdrlen:]
-
-    def process_jsonheader(self):
-        hdrlen = self._jsonheader_len
-        if len(self._recv_buffer) >= hdrlen:
-            self.jsonheader = self._json_decode(self._recv_buffer[:hdrlen], "utf-8")
-            self._recv_buffer = self._recv_buffer[hdrlen:]
-            for reqhdr in (
-                "byteorder",
-                "content-length",
-                "content-type",
-                "content-encoding",
-            ):
-                if reqhdr not in self.jsonheader:
-                    raise ValueError(f"missing required header '{reqhdr}'.")
-
-    def process_request(self):
-        content_len = self.jsonheader["content-length"]
-        if not len(self._recv_buffer) >= content_len:
-            return
-        data = self._recv_buffer[:content_len]
-        self._recv_buffer = self._recv_buffer[content_len:]
-        if self.jsonheader["content-type"] == "text/json":
-            encoding = self.jsonheader["content-encoding"]
-            self.request = self._json_decode(data, encoding)
-            print(f"received request {self.request!r} from {self.addr}")
-        else:
-            # Binary or unknown content-type
-            self.request = data
-            print(
-                f"received {self.jsonheader['content-type']} "
-                f"request from {self.addr}"
-            )
-        # Set selector to listen for write events, we're done reading.
-        self._set_selector_events_mask("w")
-
-    def create_response(self):
-        if self.jsonheader["content-type"] == "text/json":
-            response = self._create_response_json_content()
-        else:
-            # Binary or unknown content-type
-            response = self._create_response_binary_content()
-        message = self._create_message(**response)
-        self.response_created = True
-        self._send_buffer += message
-
-
-if __name__ == "__main__":
-    print("this is lib file this file only contains classes and funcs/methods")
-#+end_src
-*** src of app server
-
-#+begin_src python :tangle app-srvr.py :shebang "#!/usr/bin/env python3"
-import sys
-import socket
-import selectors
-import traceback
-
-import libsrvr
-
-sel = selectors.DefaultSelector()
-
-
-def accept_wrapper(sock):
-    conn, addr = sock.accept()  # Should be ready to read
-    print(f"accepted connection from {addr}")
-    conn.setblocking(False)
-    message = libsrvr.Message(sel, conn, addr)
-    sel.register(conn, selectors.EVENT_READ, data=message)
-
-
-def main():
-
-    if len(sys.argv) != 3:
-        print(f"usage: {sys.argv[0]} <host> <port>")
-        sys.exit(1)
-
-    host, port = sys.argv[1], int(sys.argv[2])
-    lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-    # Avoid bind() exception: OSError: [Errno 48] Address already in use
-    lsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
-    lsock.bind((host, port))
-    lsock.listen()
-    print(f"listening on {(host, port)}")
-    lsock.setblocking(False)
-    sel.register(lsock, selectors.EVENT_READ, data=None)
-
-    try:
-        while True:
-            events = sel.select(timeout=None)
-            for key, mask in events:
-                if key.data is None:
-                    accept_wrapper(key.fileobj)
-                else:
-                    message = key.data
-                    try:
-                        message.process_events(mask)
-                    except Exception:
-                        print(
-                            f"main: Error: Exception for {message.addr}:\n"
-                            f"{traceback.format_exc()}"
-                        )
-                        message.close()
-    except KeyboardInterrupt:
-        print("caught keyboard interrupt, exiting")
-    finally:
-        sel.close()
-
-
-if __name__ == "__main__":
-    main()
-#+end_src
-
-*** src of lib client
-
-#+begin_src python :tangle libclnt.py
-import sys
-import selectors
-import json
-import io
-import struct
-
-
-class Message:
-    def __init__(self, selector, sock, addr, request):
-        self.selector = selector
-        self.sock = sock
-        self.addr = addr
-        self.request = request
-        self._recv_buffer = b""
-        self._send_buffer = b""
-        self._request_queued = False
-        self._jsonheader_len = None
-        self.jsonheader = None
-        self.response = None
-
-    def _set_selector_events_mask(self, mode):
-        """Set selector to listen for events: mode is 'r', 'w', or 'rw'."""
-        if mode == "r":
-            events = selectors.EVENT_READ
-        elif mode == "w":
-            events = selectors.EVENT_WRITE
-        elif mode == "rw":
-            events = selectors.EVENT_READ | selectors.EVENT_WRITE
-        else:
-            raise ValueError(f"Invalid events mask mode {mode!r}.")
-        self.selector.modify(self.sock, events, data=self)
-
-    def _read(self):
-        try:
-            # Should be ready to read
-            data = self.sock.recv(4096)
-        except BlockingIOError:
-            # Resource temporarily unavailable (errno EWOULDBLOCK)
-            pass
-        else:
-            if data:
-                self._recv_buffer += data
-            else:
-                raise RuntimeError("Peer closed.")
-
-    def _write(self):
-        if self._send_buffer:
-            print(f"Sending {self._send_buffer!r} to {self.addr}")
-            try:
-                # Should be ready to write
-                sent = self.sock.send(self._send_buffer)
-            except BlockingIOError:
-                # Resource temporarily unavailable (errno EWOULDBLOCK)
-                pass
-            else:
-                self._send_buffer = self._send_buffer[sent:]
-
-    def _json_encode(self, obj, encoding):
-        return json.dumps(obj, ensure_ascii=False).encode(encoding)
-
-    def _json_decode(self, json_bytes, encoding):
-        tiow = io.TextIOWrapper(io.BytesIO(json_bytes), encoding=encoding, newline="")
-        obj = json.load(tiow)
-        tiow.close()
-        return obj
-
-    def _create_message(self, *, content_bytes, content_type, content_encoding):
-        jsonheader = {
-            "byteorder": sys.byteorder,
-            "content-type": content_type,
-            "content-encoding": content_encoding,
-            "content-length": len(content_bytes),
-        }
-        jsonheader_bytes = self._json_encode(jsonheader, "utf-8")
-        message_hdr = struct.pack(">H", len(jsonheader_bytes))
-        message = message_hdr + jsonheader_bytes + content_bytes
-        return message
-
-    def _process_response_json_content(self):
-        content = self.response
-        result = content.get("result")
-        print(f"Got result: {result}")
-
-    def _process_response_binary_content(self):
-        content = self.response
-        print(f"Got response: {content!r}")
-
-    def process_events(self, mask):
-        if mask & selectors.EVENT_READ:
-            self.read()
-        if mask & selectors.EVENT_WRITE:
-            self.write()
-
-    def read(self):
-        self._read()
-
-        if self._jsonheader_len is None:
-            self.process_protoheader()
-
-        if self._jsonheader_len is not None:
-            if self.jsonheader is None:
-                self.process_jsonheader()
-
-        if self.jsonheader:
-            if self.response is None:
-                self.process_response()
-
-    def write(self):
-        if not self._request_queued:
-            self.queue_request()
-
-        self._write()
-
-        if self._request_queued:
-            if not self._send_buffer:
-                # Set selector to listen for read events, we're done writing.
-                self._set_selector_events_mask("r")
-
-    def close(self):
-        print(f"Closing connection to {self.addr}")
-        try:
-            self.selector.unregister(self.sock)
-        except Exception as e:
-            print(f"Error: selector.unregister() exception for " f"{self.addr}: {e!r}")
-
-        try:
-            self.sock.close()
-        except OSError as e:
-            print(f"Error: socket.close() exception for {self.addr}: {e!r}")
-        finally:
-            # Delete reference to socket object for garbage collection
-            self.sock = None
-
-    def queue_request(self):
-        content = self.request["content"]
-        content_type = self.request["type"]
-        content_encoding = self.request["encoding"]
-        if content_type == "text/json":
-            req = {
-                "content_bytes": self._json_encode(content, content_encoding),
-                "content_type": content_type,
-                "content_encoding": content_encoding,
-            }
-        else:
-            req = {
-                "content_bytes": content,
-                "content_type": content_type,
-                "content_encoding": content_encoding,
-            }
-        message = self._create_message(**req)
-        self._send_buffer += message
-        self._request_queued = True
-
-    def process_protoheader(self):
-        hdrlen = 2
-        if len(self._recv_buffer) >= hdrlen:
-            self._jsonheader_len = struct.unpack(">H", self._recv_buffer[:hdrlen])[0]
-            self._recv_buffer = self._recv_buffer[hdrlen:]
-
-    def process_jsonheader(self):
-        hdrlen = self._jsonheader_len
-        if len(self._recv_buffer) >= hdrlen:
-            self.jsonheader = self._json_decode(self._recv_buffer[:hdrlen], "utf-8")
-            self._recv_buffer = self._recv_buffer[hdrlen:]
-            for reqhdr in (
-                "byteorder",
-                "content-length",
-                "content-type",
-                "content-encoding",
-            ):
-                if reqhdr not in self.jsonheader:
-                    raise ValueError(f"Missing required header '{reqhdr}'.")
-
-    def process_response(self):
-        content_len = self.jsonheader["content-length"]
-        if not len(self._recv_buffer) >= content_len:
-            return
-        data = self._recv_buffer[:content_len]
-        self._recv_buffer = self._recv_buffer[content_len:]
-        if self.jsonheader["content-type"] == "text/json":
-            encoding = self.jsonheader["content-encoding"]
-            self.response = self._json_decode(data, encoding)
-            print(f"Received response {self.response!r} from {self.addr}")
-            self._process_response_json_content()
-        else:
-            # Binary or unknown content-type
-            self.response = data
-            print(
-                f"Received {self.jsonheader['content-type']} "
-                f"response from {self.addr}"
-            )
-            self._process_response_binary_content()
-        # Close when response has been processed
-        self.close()
-
-
-if __name__ == "__main__":
-    print("this is lib file this file only contains classes and funcs/methods")
-#+end_src
-
-*** src of app client
-
-#+begin_src python :tangle app-clnt.py :shebang "#!/usr/bin/env python3"
-import sys
-import socket
-import selectors
-import traceback
-
-import libclnt
-
-sel = selectors.DefaultSelector()
-
-
-def create_request(action: str, value: str) -> dict:
-    """
-    create dict object by given args
-    - WARN there was a bug in this func the value can't be bytes object
-    """
-    if action == "search":
-        return dict(
-            type="text/json",
-            encoding="utf-8",
-            content=dict(action=action, value=value),
-        )
-    else:
-        return dict(
-            type="binary/custom-client-binary-type",
-            encoding="binary",
-            content=bytes(
-                action + value, encoding="utf-8"
-            ),  #  - WARN there was a bug in 'action + value' the value can't be bytes object
-        )
-
-
-def start_connection(host: str, port: int, request: dict):
-    """
-    connects given connection (host,port) and sends given request
-    """
-    addr = (host, port)
-    print(f"Starting connection to {addr}")
-    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-    sock.setblocking(False)
-    sock.connect_ex(addr)
-    events = selectors.EVENT_READ | selectors.EVENT_WRITE
-    message = libclnt.Message(sel, sock, addr, request)
-    sel.register(sock, events, data=message)
-
-
-def main():
-
-    if len(sys.argv) != 5:
-        print(f"usage: {sys.argv[0]} <host> <port> <action> <value>")
-        sys.exit(1)
-
-    host, port = sys.argv[1], int(sys.argv[2])
-    action, value = sys.argv[3], sys.argv[4]
-    request = create_request(action, value)
-    start_connection(host, port, request)
-
-    try:
-        while True:
-            events = sel.select(timeout=1)
-            for key, mask in events:
-                message = key.data
-                try:
-                    message.process_events(mask)
-                except Exception:
-                    print(
-                        f"main: error: exception for {message.addr}:\n"
-                        f"{traceback.format_exc()}"
-                    )
-                    message.close()
-            # check for a socket being monitored to continue.
-            if not sel.get_map():
-                break
-    except KeyboardInterrupt:
-        print("caught keyboard interrupt, exiting")
-    finally:
-        sel.close()
-
-
-if __name__ == "__main__":
-    main()
-#+end_src
-
-* very basic dns to ip tool
-
-#+begin_src python :tangle deneme.py
-import socket
-
-url = "www.google.com"
-
-try:
-    host_ip = socket.gethostbyname(url)
-except sockect.gaierror:
-    print("there was an error resolving the host")
-    sys.exit()
-
-print(f"{url} 's ip : {host_ip}")
-#+end_src
-
-
-* this document heavily used this sources
-
-- [[https://realpython.com/python-sockets/][realpython.com - python sockets - where examples are copied from]]
-- [[https://docs.python.org/3/library/socket.html][doc.python.org - socket]]
-
-* what is this document
-
- this documents my notes that mostly  (most of examples and how example works) copied,rewrite in my understandings, from given sources
diff --git a/python/threading_parallel_processing/index.html b/python/threading_parallel_processing/index.html
deleted file mode 100644
index 91a86e4..0000000
--- a/python/threading_parallel_processing/index.html
+++ /dev/null
@@ -1,2630 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
-"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
-<head>
-<!-- 2023-03-12 Sun 12:54 -->
-<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
-<meta name="viewport" content="width=device-width, initial-scale=1" />
-<title>Threading in Python</title>
-<meta name="author" content="mal1kc" />
-<meta name="generator" content="Org Mode" />
-<style>
-  #content { max-width: 60em; margin: auto; }
-  .title  { text-align: center;
-             margin-bottom: .2em; }
-  .subtitle { text-align: center;
-              font-size: medium;
-              font-weight: bold;
-              margin-top:0; }
-  .todo   { font-family: monospace; color: red; }
-  .done   { font-family: monospace; color: green; }
-  .priority { font-family: monospace; color: orange; }
-  .tag    { background-color: #eee; font-family: monospace;
-            padding: 2px; font-size: 80%; font-weight: normal; }
-  .timestamp { color: #bebebe; }
-  .timestamp-kwd { color: #5f9ea0; }
-  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
-  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
-  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
-  .underline { text-decoration: underline; }
-  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
-  p.verse { margin-left: 3%; }
-  pre {
-    border: 1px solid #e6e6e6;
-    border-radius: 3px;
-    background-color: #f2f2f2;
-    padding: 8pt;
-    font-family: monospace;
-    overflow: auto;
-    margin: 1.2em;
-  }
-  pre.src {
-    position: relative;
-    overflow: auto;
-  }
-  pre.src:before {
-    display: none;
-    position: absolute;
-    top: -8px;
-    right: 12px;
-    padding: 3px;
-    color: #555;
-    background-color: #f2f2f299;
-  }
-  pre.src:hover:before { display: inline; margin-top: 14px;}
-  /* Languages per Org manual */
-  pre.src-asymptote:before { content: 'Asymptote'; }
-  pre.src-awk:before { content: 'Awk'; }
-  pre.src-authinfo::before { content: 'Authinfo'; }
-  pre.src-C:before { content: 'C'; }
-  /* pre.src-C++ doesn't work in CSS */
-  pre.src-clojure:before { content: 'Clojure'; }
-  pre.src-css:before { content: 'CSS'; }
-  pre.src-D:before { content: 'D'; }
-  pre.src-ditaa:before { content: 'ditaa'; }
-  pre.src-dot:before { content: 'Graphviz'; }
-  pre.src-calc:before { content: 'Emacs Calc'; }
-  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
-  pre.src-fortran:before { content: 'Fortran'; }
-  pre.src-gnuplot:before { content: 'gnuplot'; }
-  pre.src-haskell:before { content: 'Haskell'; }
-  pre.src-hledger:before { content: 'hledger'; }
-  pre.src-java:before { content: 'Java'; }
-  pre.src-js:before { content: 'Javascript'; }
-  pre.src-latex:before { content: 'LaTeX'; }
-  pre.src-ledger:before { content: 'Ledger'; }
-  pre.src-lisp:before { content: 'Lisp'; }
-  pre.src-lilypond:before { content: 'Lilypond'; }
-  pre.src-lua:before { content: 'Lua'; }
-  pre.src-matlab:before { content: 'MATLAB'; }
-  pre.src-mscgen:before { content: 'Mscgen'; }
-  pre.src-ocaml:before { content: 'Objective Caml'; }
-  pre.src-octave:before { content: 'Octave'; }
-  pre.src-org:before { content: 'Org mode'; }
-  pre.src-oz:before { content: 'OZ'; }
-  pre.src-plantuml:before { content: 'Plantuml'; }
-  pre.src-processing:before { content: 'Processing.js'; }
-  pre.src-python:before { content: 'Python'; }
-  pre.src-R:before { content: 'R'; }
-  pre.src-ruby:before { content: 'Ruby'; }
-  pre.src-sass:before { content: 'Sass'; }
-  pre.src-scheme:before { content: 'Scheme'; }
-  pre.src-screen:before { content: 'Gnu Screen'; }
-  pre.src-sed:before { content: 'Sed'; }
-  pre.src-sh:before { content: 'shell'; }
-  pre.src-sql:before { content: 'SQL'; }
-  pre.src-sqlite:before { content: 'SQLite'; }
-  /* additional languages in org.el's org-babel-load-languages alist */
-  pre.src-forth:before { content: 'Forth'; }
-  pre.src-io:before { content: 'IO'; }
-  pre.src-J:before { content: 'J'; }
-  pre.src-makefile:before { content: 'Makefile'; }
-  pre.src-maxima:before { content: 'Maxima'; }
-  pre.src-perl:before { content: 'Perl'; }
-  pre.src-picolisp:before { content: 'Pico Lisp'; }
-  pre.src-scala:before { content: 'Scala'; }
-  pre.src-shell:before { content: 'Shell Script'; }
-  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
-  /* additional language identifiers per "defun org-babel-execute"
-       in ob-*.el */
-  pre.src-cpp:before  { content: 'C++'; }
-  pre.src-abc:before  { content: 'ABC'; }
-  pre.src-coq:before  { content: 'Coq'; }
-  pre.src-groovy:before  { content: 'Groovy'; }
-  /* additional language identifiers from org-babel-shell-names in
-     ob-shell.el: ob-shell is the only babel language using a lambda to put
-     the execution function name together. */
-  pre.src-bash:before  { content: 'bash'; }
-  pre.src-csh:before  { content: 'csh'; }
-  pre.src-ash:before  { content: 'ash'; }
-  pre.src-dash:before  { content: 'dash'; }
-  pre.src-ksh:before  { content: 'ksh'; }
-  pre.src-mksh:before  { content: 'mksh'; }
-  pre.src-posh:before  { content: 'posh'; }
-  /* Additional Emacs modes also supported by the LaTeX listings package */
-  pre.src-ada:before { content: 'Ada'; }
-  pre.src-asm:before { content: 'Assembler'; }
-  pre.src-caml:before { content: 'Caml'; }
-  pre.src-delphi:before { content: 'Delphi'; }
-  pre.src-html:before { content: 'HTML'; }
-  pre.src-idl:before { content: 'IDL'; }
-  pre.src-mercury:before { content: 'Mercury'; }
-  pre.src-metapost:before { content: 'MetaPost'; }
-  pre.src-modula-2:before { content: 'Modula-2'; }
-  pre.src-pascal:before { content: 'Pascal'; }
-  pre.src-ps:before { content: 'PostScript'; }
-  pre.src-prolog:before { content: 'Prolog'; }
-  pre.src-simula:before { content: 'Simula'; }
-  pre.src-tcl:before { content: 'tcl'; }
-  pre.src-tex:before { content: 'TeX'; }
-  pre.src-plain-tex:before { content: 'Plain TeX'; }
-  pre.src-verilog:before { content: 'Verilog'; }
-  pre.src-vhdl:before { content: 'VHDL'; }
-  pre.src-xml:before { content: 'XML'; }
-  pre.src-nxml:before { content: 'XML'; }
-  /* add a generic configuration mode; LaTeX export needs an additional
-     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
-  pre.src-conf:before { content: 'Configuration File'; }
-
-  table { border-collapse:collapse; }
-  caption.t-above { caption-side: top; }
-  caption.t-bottom { caption-side: bottom; }
-  td, th { vertical-align:top;  }
-  th.org-right  { text-align: center;  }
-  th.org-left   { text-align: center;   }
-  th.org-center { text-align: center; }
-  td.org-right  { text-align: right;  }
-  td.org-left   { text-align: left;   }
-  td.org-center { text-align: center; }
-  dt { font-weight: bold; }
-  .footpara { display: inline; }
-  .footdef  { margin-bottom: 1em; }
-  .figure { padding: 1em; }
-  .figure p { text-align: center; }
-  .equation-container {
-    display: table;
-    text-align: center;
-    width: 100%;
-  }
-  .equation {
-    vertical-align: middle;
-  }
-  .equation-label {
-    display: table-cell;
-    text-align: right;
-    vertical-align: middle;
-  }
-  .inlinetask {
-    padding: 10px;
-    border: 2px solid gray;
-    margin: 10px;
-    background: #ffffcc;
-  }
-  #org-div-home-and-up
-   { text-align: right; font-size: 70%; white-space: nowrap; }
-  textarea { overflow-x: auto; }
-  .linenr { font-size: smaller }
-  .code-highlighted { background-color: #ffff00; }
-  .org-info-js_info-navigation { border-style: none; }
-  #org-info-js_console-label
-    { font-size: 10px; font-weight: bold; white-space: nowrap; }
-  .org-info-js_search-highlight
-    { background-color: #ffff00; color: #000000; font-weight: bold; }
-  .org-svg { }
-</style>
-</head>
-<body>
-<div id="content" class="content">
-<h1 class="title">Threading in Python</h1>
-<div id="table-of-contents" role="doc-toc">
-<h2>Table of Contents</h2>
-<div id="text-table-of-contents" role="doc-toc">
-<ul>
-<li><a href="#orgb1eeecd">1. what are threads</a></li>
-<li><a href="#org54a0631">2. thread vs process</a></li>
-<li><a href="#orgb86250b">3. life-cycle of thread</a></li>
-<li><a href="#org313a0f7">4. run a func in thread</a>
-<ul>
-<li><a href="#org9b310c9">4.1. how to run a func in thread</a>
-<ul>
-<li><a href="#org5c8ba20">4.1.1. example</a></li>
-<li><a href="#org7afa7f6">4.1.2. example with arguments</a></li>
-</ul>
-</li>
-</ul>
-</li>
-<li><a href="#orgc6ccd93">5. extend the thread class</a>
-<ul>
-<li><a href="#org49fb3d2">5.1. possible usage cases</a></li>
-<li><a href="#orga037faa">5.2. example of extending the thread class</a></li>
-<li><a href="#org977ca04">5.3. example of extending the thread class with return values</a></li>
-</ul>
-</li>
-<li><a href="#org62a7133">6. thread instance attributes</a>
-<ul>
-<li><a href="#org160f6fc">6.1. thread name</a></li>
-<li><a href="#org0c1b0b9">6.2. thread daemon</a></li>
-<li><a href="#org958cb0f">6.3. thread identifier</a></li>
-<li><a href="#org8c38ed3">6.4. thread native identifier</a></li>
-<li><a href="#org6dcfaf8">6.5. thread alive status</a>
-<ul>
-<li><a href="#org787b9e2">6.5.1. in example:</a></li>
-</ul>
-</li>
-</ul>
-</li>
-<li><a href="#orga449a90">7. configure threads</a>
-<ul>
-<li><a href="#orgd774ae8">7.1. how to configure thread name</a></li>
-<li><a href="#orgf96bb6a">7.2. how to configure thread daemon</a>
-<ul>
-<li><a href="#org3b975d2">7.2.1. for example:</a></li>
-</ul>
-</li>
-</ul>
-</li>
-<li><a href="#org126819c">8. whats main thread</a></li>
-<li><a href="#orgf990e62">9. Thread Utilities</a>
-<ul>
-<li><a href="#org46cc125">9.1. number of active threads</a></li>
-<li><a href="#orgd82b10c">9.2. current thread</a></li>
-<li><a href="#orgf7db83d">9.3. thread identifier</a></li>
-<li><a href="#org47a8693">9.4. native thread identifier</a></li>
-<li><a href="#orgdab4b14">9.5. enumarate active threads</a></li>
-</ul>
-</li>
-<li><a href="#org9cf6454">10. thread exception handling</a>
-<ul>
-<li><a href="#org30352a6">10.1. unhandled exception</a></li>
-<li><a href="#org9858b86">10.2. exception hook</a>
-<ul>
-<li><a href="#orgfa903cb">10.2.1. example</a></li>
-</ul>
-</li>
-</ul>
-</li>
-<li><a href="#org2190760">11. limitation of threads in cpython</a></li>
-<li><a href="#orgf32c134">12. when to use thread</a>
-<ul>
-<li><a href="#orge84a97b">12.1. use threads for blocking IO</a></li>
-<li><a href="#org2e4df22">12.2. use threads external c code (that realses the GIL)</a></li>
-<li><a href="#org3b32456">12.3. use threads with (some) third-party python interpreter</a></li>
-</ul>
-</li>
-<li><a href="#org5bb2439">13. threads blocking calls</a>
-<ul>
-<li><a href="#org435eb62">13.1. blocking calls on concurrency primitives</a></li>
-<li><a href="#org9fee928">13.2. blocking calls for I/O</a></li>
-<li><a href="#orga891c22">13.3. blocking calls to sleep</a></li>
-</ul>
-</li>
-<li><a href="#org1cae294">14. thread-local data</a>
-<ul>
-<li><a href="#org426f46c">14.1. example</a></li>
-</ul>
-</li>
-<li><a href="#orgcd19a6f">15. thread mutex lock - <i>threading.Lock</i></a>
-<ul>
-<li><a href="#orgd956ce3">15.1. what is mutual exclusion lock</a>
-<ul>
-<li><a href="#orgc25a9ea">15.1.1. why we need mutual exclusion lock</a></li>
-<li><a href="#orgaf8ea4d">15.1.2. description of mutex</a></li>
-</ul>
-</li>
-<li><a href="#orgcb425b7">15.2. how to use mutex lock</a>
-<ul>
-<li><a href="#org3102e11">15.2.1. for example</a></li>
-</ul>
-</li>
-<li><a href="#org73d3c2b">15.3. example of using mutex lock</a></li>
-</ul>
-</li>
-<li><a href="#orgc3e8867">16. thread reentrant lock  - <i>threading.RLock</i></a>
-<ul>
-<li><a href="#org295fc45">16.1. what is reentrant lock</a>
-<ul>
-<li><a href="#org8c510c6">16.1.1. why we neet reentrant lock</a></li>
-<li><a href="#orge5fb020">16.1.2. description of reentrant lock</a></li>
-</ul>
-</li>
-<li><a href="#org629285b">16.2. how to use reentrant lock</a></li>
-<li><a href="#org7ff72d9">16.3. example of using reentrant lock</a></li>
-</ul>
-</li>
-<li><a href="#orga6e7ff5">17. thread condition - <i>threading.Condition</i></a>
-<ul>
-<li><a href="#org0b38af1">17.1. what is a threading condition</a></li>
-<li><a href="#org7b78541">17.2. how to use condition object</a></li>
-<li><a href="#orgf37a8fb">17.3. example of wait and notify with a condition</a></li>
-</ul>
-</li>
-<li><a href="#orgee91dc8">18. thread semaphore - <i>threading.Semaphore</i></a>
-<ul>
-<li><a href="#org9d6be22">18.1. what is a semaphore</a></li>
-<li><a href="#org67e18a6">18.2. how to use a semaphore</a>
-<ul>
-<li><a href="#org177adf7">18.2.1. acquiring and releasing</a></li>
-</ul>
-</li>
-<li><a href="#org381d49a">18.3. example</a></li>
-</ul>
-</li>
-<li><a href="#org1b5c80e">19. thread event - <i>threading.Event</i></a>
-<ul>
-<li><a href="#org2e843aa">19.1. how to use event object</a></li>
-<li><a href="#orgd456f71">19.2. example</a></li>
-</ul>
-</li>
-<li><a href="#orgba6e4f7">20. timer threads - <i>threading.Timer</i></a>
-<ul>
-<li><a href="#org94d3852">20.1. how to use a timer thread</a></li>
-<li><a href="#org35cc1f6">20.2. example of using a timer thread</a></li>
-</ul>
-</li>
-<li><a href="#org01509ca">21. thread barrier - <i>threading.Barrier</i></a>
-<ul>
-<li><a href="#orgb196bd1">21.1. what is barrier</a></li>
-<li><a href="#orgc3226d4">21.2. how to use barrier</a></li>
-<li><a href="#org9378a4e">21.3. example</a></li>
-</ul>
-</li>
-<li><a href="#org86b3023">22. pyhton : threading best practices</a>
-<ul>
-<li><a href="#org3b4e83b">22.1. tip 1: use context managers</a>
-<ul>
-<li><a href="#org7583928">22.1.1. not use this</a></li>
-<li><a href="#orgb87f71b">22.1.2. use this for better control over threads (more safe)</a></li>
-<li><a href="#org1637c85">22.1.3. the real benefit</a></li>
-</ul>
-</li>
-<li><a href="#orgc9eb2d5">22.2. tip 2 : Use timedouts when waiting</a></li>
-<li><a href="#orgc1d4a1f">22.3. tip 3: use a mutex to protect critical sections</a></li>
-<li><a href="#org7a0eecf">22.4. tip 4: acquire locks in order</a></li>
-</ul>
-</li>
-<li><a href="#org67bc6ac">23. python : threading common errors</a>
-<ul>
-<li><a href="#orgca91685">23.1. race conditions</a></li>
-<li><a href="#orge5722db">23.2. thread deadlocks</a></li>
-<li><a href="#orgdd4862a">23.3. thread livelocks</a></li>
-</ul>
-</li>
-<li><a href="#org1ec93b4">24. python threading common questions</a></li>
-<li><a href="#org9727e75">25. resources</a></li>
-</ul>
-</div>
-</div>
-
-<div id="outline-container-orgb1eeecd" class="outline-2">
-<h2 id="orgb1eeecd"><span class="section-number-2">1.</span> what are threads</h2>
-<div class="outline-text-2" id="text-1">
-<p>
-threads refers to thread of execution in computer program
-</p>
-
-<blockquote>
-<p>
-Thread: The operating system object that executess the instructions of a process
-</p>
-<ul class="org-ul">
-<li>book: page 273,the art of concurency,2009.</li>
-</ul>
-</blockquote>
-
-<p>
-when we run python script, it starts an instance of python interpreter that runs our code in the main thread.
-the main threads is the default thread of a python process
-</p>
-
-<p>
-we may develop our program to  perform tasks concurently in that case we may need threads,these are concurent threads of execution without our program
-example of this will be:
-</p>
-
-<ul class="org-ul">
-<li>execution funtion calls concurently</li>
-<li>execution object methods concurently</li>
-</ul>
-
-<p>
-a python thread is an object representation of native thread provided by operating system
-</p>
-
-<p>
-when we create and run a new thread, Python will make system calls on the underlaying op. system and request new thread be created and start running new thread
-</p>
-
-<p>
-the code in new threads may or may not be executed in parallel,even though the threads are executed concurently.
-</p>
-
-<p>
-these are number of reasons for this,such as:
-</p>
-
-<ul class="org-ul">
-<li>the underlaying hardware may or may not support parallel execution (e.g. one vs multiple CPU cores)</li>
-<li>the python interpreter may or may not permity multiple threads execute in parallel</li>
-</ul>
-
-<blockquote>
-<p>
-this highlights the distiction between concurent and parallel execution
-</p>
-</blockquote>
-
-<ul class="org-ul">
-<li><b>Concurrent</b> : Code that can be executed out of order</li>
-<li><b>Parallel</b> : Capability to execute code simultaneously</li>
-</ul>
-</div>
-</div>
-
-<div id="outline-container-org54a0631" class="outline-2">
-<h2 id="org54a0631"><span class="section-number-2">2.</span> thread vs process</h2>
-<div class="outline-text-2" id="text-2">
-<p>
-a process refers to a computer process
-</p>
-
-<blockquote>
-<p>
-process: the operating system&rsquo;s spawned and controlled entity that encapsulates an executing application.
-a process has two main functions. the first is to act as the resource holder for the application,
-and the second is to execute the instructions of the application.
-</p>
-<ul class="org-ul">
-<li>book: page 271,the art of concurency,2009</li>
-</ul>
-</blockquote>
-
-<p>
-the op system controls how new processes are created on some system,that may require spawning a new process,and on others,it may require that process is forked.
-in Cpython implementation we not need to worry because python interpreter is manage
-creating new processes.
-</p>
-
-<p>
-a thread always exists within a process and represents the manner in which instructions or code is executed.
-</p>
-
-<p>
-a process will have at least one thread, called the main thread.Any additional
-threads that we create within the process will belong to that process.
-</p>
-
-<p>
-the python process will terminate once all(non background threads) are terminated
-</p>
-
-<ul class="org-ul">
-<li><b>process</b>: an instance of the python interpreter has atleast one thread called MainThread</li>
-<li><b>thread</b>: a thread of execution within Python process,such as the MainThread or new thread.</li>
-</ul>
-</div>
-</div>
-
-<div id="outline-container-orgb86250b" class="outline-2">
-<h2 id="orgb86250b"><span class="section-number-2">3.</span> life-cycle of thread</h2>
-<div class="outline-text-2" id="text-3">
-<p>
-a thread in python is object instanced from  <b>threading.Thread</b> class
-</p>
-
-<p>
-once a thead is started, interpreter will interface with the operating system and request that new native thread be created. the instance of <b>threading.Thread</b>
-the provides a python-based reference to his underlaying native thread.
-</p>
-
-<p>
-each thread follows same life-cycle . understanding of its life-cycle help with
-concurent programming in python.
-</p>
-
-<p>
-for example:
-</p>
-
-<ul class="org-ul">
-<li>the diffrence between creatimg and starting a thread</li>
-
-<li>the diffrence between run and start</li>
-
-<li>the diffrence between blocked and terminated</li>
-</ul>
-
-<p>
-while running, the thread may be executing code or may be blocked,waiting on something such as another thread or external resource.although, not all threads may block, it is optinal base on specific use case for the new thread.
-</p>
-
-<ol class="org-ol">
-<li>new thread</li>
-<li>running thread
-<ol class="org-ol">
-<li>blocked thread (optinal).</li>
-</ol></li>
-<li>terminated thread.</li>
-</ol>
-
-<p>
-A new thread is a thread that has been constructed by. creating an instance of the <b>threading.Thread</b> class
-</p>
-
-<p>
-a new thread can transition to a running thread by calling the start() function.
-</p>
-
-<p>
-a running thread may block in many ways, such as reading or writing from a file or a socket or by waiting on concurency primitive such as semaphore or a lock
-after blocking,the thread will run again.
-</p>
-
-<p>
-finaly, a thread may terminate once it has finished executing its code or by raising
-error or exception
-</p>
-
-<p>
-<a href="./thread-life-cycle.webp">thread life cycle diaram</a>
-</p>
-</div>
-</div>
-
-<div id="outline-container-org313a0f7" class="outline-2">
-<h2 id="org313a0f7"><span class="section-number-2">4.</span> run a func in thread</h2>
-<div class="outline-text-2" id="text-4">
-<p>
-python funcs can executed in a seperatie thread using <b>threading.Thread</b> class
-</p>
-</div>
-
-<div id="outline-container-org9b310c9" class="outline-3">
-<h3 id="org9b310c9"><span class="section-number-3">4.1.</span> how to run a func in thread</h3>
-<div class="outline-text-3" id="text-4-1">
-<p>
-the func executed in another thread may have args in which case can be specificed as aa tuple and passed to the &ldquo;<b>args</b>&rdquo; argument of the threading.threading class constructor or as dictionart to the &ldquo;<b>kwargs</b>&rdquo; argument.
-</p>
-
-<p>
-the <b>start()</b> func will return immediately and the operating system will execute    the function in a seperate thread as soon as it is able.
-</p>
-
-<p>
-we do not have control over when the thread will execute precisely or which cpu core wwill execute it. both of these are low-level responsibilities that are handled by operating system.
-</p>
-
-<blockquote>
-<p>
-doing nessesary imports for examples
-</p>
-</blockquote>
-
-<div class="org-src-container">
-<pre class="src src-python">
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">doing nessesary imports for examples</span>
-<span style="color: #b5bd68;">import</span> threading
-<span style="color: #b5bd68;">import</span> time
-
-</pre>
-</div>
-</div>
-
-
-<div id="outline-container-org5c8ba20" class="outline-4">
-<h4 id="org5c8ba20"><span class="section-number-4">4.1.1.</span> example</h4>
-<div class="outline-text-4" id="text-4-1-1">
-<div class="org-src-container">
-<pre class="src src-python"><span style="color: #b5bd68;">from</span> __init__ <span style="color: #b5bd68;">import</span> *
-
-<span style="color: #b5bd68;">def</span> <span style="color: #de935f;">task</span>():
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">block for 1 second</span>
-    time.sleep(<span style="color: #81a2be;">1</span>)
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">display a message</span>
-
-    <span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'this is from another thread'</span>)
-
-<span style="color: #f0c674;">thread</span> = threading.Thread(target=task)
-thread.start()
-<span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'waiting fo the thread ..'</span>)
-thread.join() <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">explicitly waiting to finish thread</span>
-</pre>
-</div>
-
-<p>
-running the example first creates instance  of threeding.Thread then calls the <b>start()</b> func.This does not start the thread immediately,but instead allows to operating system to schedule the function to execute as soon as possible.
-</p>
-
-<p>
-the main thread then prints a message &rsquo;<i>waiting &#x2026;</i>&rsquo; ,then calls the <b>join()</b> function to explicitly block and wait for the new thread to finish executing.
-</p>
-</div>
-</div>
-
-<div id="outline-container-org7afa7f6" class="outline-4">
-<h4 id="org7afa7f6"><span class="section-number-4">4.1.2.</span> example with arguments</h4>
-<div class="outline-text-4" id="text-4-1-2">
-<div class="org-src-container">
-<pre class="src src-python"><span style="color: #b5bd68;">from</span> __init__ <span style="color: #b5bd68;">import</span> *
-
-<span style="color: #b5bd68;">def</span> <span style="color: #de935f;">task</span>(sleep_time,message):
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">block for 1 second</span>
-    time.sleep(sleep_time)
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">display a message</span>
-    <span style="color: #b294bb;">print</span>(message)
-
-
-<span style="color: #f0c674;">thread</span> = threading.Thread(target=task,args=(<span style="color: #81a2be;">1.5</span>,<span style="color: #8abeb7;">'new message from another thread'</span>))
-thread.start()
-<span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'waiting fo the thread ..'</span>)
-thread.join() <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">explicitly waiting to finish thread</span>
-</pre>
-</div>
-</div>
-</div>
-</div>
-</div>
-
-<div id="outline-container-orgc6ccd93" class="outline-2">
-<h2 id="orgc6ccd93"><span class="section-number-2">5.</span> extend the thread class</h2>
-<div class="outline-text-2" id="text-5">
-<p>
-we can also execute funcs in another thread by extending the <b>threading.Thread</b> class and overriding the run() function.
-</p>
-
-<p>
-In this section we will look at some examples of extending <b>thread.Thread</b> class
-</p>
-</div>
-
-<div id="outline-container-org49fb3d2" class="outline-3">
-<h3 id="org49fb3d2"><span class="section-number-3">5.1.</span> possible usage cases</h3>
-<div class="outline-text-3" id="text-5-1">
-<p>
-given that it is a custom class,you can defina a constructor for the class and use it to pass in data that may be needed in the <b>run()</b> function, stored as instance variables (attributes).
-</p>
-
-<p>
-you can also define additional functions on the class to split up the work you may need to complete another thread.
-</p>
-
-<p>
-finally, attributes caan also be used to store the results of any calculation or IO performed in another thread that may be need to be retrieved afterward.
-</p>
-</div>
-</div>
-
-<div id="outline-container-orga037faa" class="outline-3">
-<h3 id="orga037faa"><span class="section-number-3">5.2.</span> example of extending the thread class</h3>
-<div class="outline-text-3" id="text-5-2">
-<p>
-example code :
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python"><span style="color: #b5bd68;">class</span> <span style="color: #81a2be;">CustomThread</span>(Thread):
-    ...
-</pre>
-</div>
-
-<p>
-this will inherit <b>Thread</b> class to our <b>CustomThread</b> class,then we need override
-<b>run()</b> func to execute another threads funcs,overriding a function very basic as syntax:
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python"><span style="color: #b5bd68;">def</span> <span style="color: #de935f;">run</span>(<span style="color: #b5bd68;">self</span>):
-    sleep(<span style="color: #81a2be;">1</span>)
-    <span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'this is coming from another thread'</span>)
-
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create the thread</span>
-<span style="color: #f0c674;">thread</span> = CustomThread()
-
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">start the thread</span>
-
-thread.start()
-
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">wait for the thread finish</span>
-
-<span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'waiting for the thread to finish'</span>)
-
-thread.join()
-
-</pre>
-</div>
-
-
-<p>
-complete code would be like:
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python"><span style="color: #b5bd68;">from</span> __init__ <span style="color: #b5bd68;">import</span> *
-
-<span style="color: #b5bd68;">class</span> <span style="color: #81a2be;">CustomThread</span>(threading.Thread):
-    <span style="color: #b5bd68;">def</span> <span style="color: #de935f;">run</span>(<span style="color: #b5bd68;">self</span>):
-        time.sleep(<span style="color: #81a2be;">1</span>)
-        <span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'this is coming from another thread'</span>)
-
-
-<span style="color: #f0c674;">thread</span> = CustomThread()
-thread.start()
-<span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'waitin for thread finish'</span>)
-thread.join()
-</pre>
-</div>
-</div>
-</div>
-
-<div id="outline-container-org977ca04" class="outline-3">
-<h3 id="org977ca04"><span class="section-number-3">5.3.</span> example of extending the thread class with return values</h3>
-<div class="outline-text-3" id="text-5-3">
-<div class="org-src-container">
-<pre class="src src-python"><span style="color: #b5bd68;">from</span> __init__ <span style="color: #b5bd68;">import</span> *
-
-<span style="color: #b5bd68;">class</span> <span style="color: #81a2be;">CustomThread</span>(threading.Thread):
-    <span style="color: #b5bd68;">def</span> <span style="color: #de935f;">run</span>(<span style="color: #b5bd68;">self</span>):
-        time.sleep(<span style="color: #81a2be;">1</span>)
-        <span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'this is coming from another thread'</span>)
-        <span style="color: #b5bd68;">self</span>.<span style="color: #f0c674;">value</span> = <span style="color: #81a2be;">99</span>
-
-<span style="color: #f0c674;">thread</span> = CustomThread()
-thread.start()
-<span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'waitin for thread finish'</span>)
-thread.join()
-<span style="color: #f0c674;">value</span> = thread.value
-<span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'</span>{value=}<span style="color: #8abeb7;">'</span>)
-
-</pre>
-</div>
-</div>
-</div>
-</div>
-
-<div id="outline-container-org62a7133" class="outline-2">
-<h2 id="org62a7133"><span class="section-number-2">6.</span> thread instance attributes</h2>
-<div class="outline-text-2" id="text-6">
-<p>
-an instance of the thread class provides a handle of a thread of execution.
-it provides attributes that we can use to query properties and the status of the underlaying thread.
-</p>
-</div>
-
-<div id="outline-container-org160f6fc" class="outline-3">
-<h3 id="org160f6fc"><span class="section-number-3">6.1.</span> thread name</h3>
-<div class="outline-text-3" id="text-6-1">
-<p>
-threads are named automatically in a somewhat unique manner within each process withe the form &ldquo;Thread-%d&rdquo; where %d is the integer indicating the thread number within the process,e.g. Thread-1 for the first thread created.
-</p>
-</div>
-</div>
-
-<div id="outline-container-org0c1b0b9" class="outline-3">
-<h3 id="org0c1b0b9"><span class="section-number-3">6.2.</span> thread daemon</h3>
-<div class="outline-text-3" id="text-6-2">
-<p>
-a thread may be a deamon thread, daemon threads is the name givent to background threads.by default threads are non-daemon threads.
-</p>
-
-<p>
-a python program will only exit when all non-daemon threads have finished exiting. for example , the main threads is a non-daemon threads.this means that daemon threads can run in the background and do not have to finish or be explicitly excited for the program end.
-</p>
-</div>
-</div>
-
-<div id="outline-container-org958cb0f" class="outline-3">
-<h3 id="org958cb0f"><span class="section-number-3">6.3.</span> thread identifier</h3>
-<div class="outline-text-3" id="text-6-3">
-<p>
-each thread has unique identifier (id) within python process,assigned by python interpreter.
-</p>
-
-<p>
-the identifier is a read-only positive integer value and is assigned only after thread has been started.
-</p>
-
-<p>
-can be accesed via <b>&ldquo;ident&rdquo;</b> property
-</p>
-</div>
-</div>
-
-<div id="outline-container-org8c38ed3" class="outline-3">
-<h3 id="org8c38ed3"><span class="section-number-3">6.4.</span> thread native identifier</h3>
-<div class="outline-text-3" id="text-6-4">
-<p>
-each thread has unique identifier assigned by the operating system.
-</p>
-
-<p>
-python threads (cpython) are real native threads,means that each thread we created is actually created and managed (scheduled) by operating system.As such, the operating system will assing a unique integer to each thread that is created on the system (across processes).
-</p>
-
-<p>
-can be acced via <b>&ldquo;native<sub>id</sub>&rdquo;</b> property
-</p>
-
-<p>
-it is assigned after thread has been started
-</p>
-</div>
-</div>
-
-<div id="outline-container-org6dcfaf8" class="outline-3">
-<h3 id="org6dcfaf8"><span class="section-number-3">6.5.</span> thread alive status</h3>
-<div class="outline-text-3" id="text-6-5">
-<p>
-thread class property that holds is thread running or dead (non-started or finished)
-</p>
-</div>
-
-<div id="outline-container-org787b9e2" class="outline-4">
-<h4 id="org787b9e2"><span class="section-number-4">6.5.1.</span> in example:</h4>
-<div class="outline-text-4" id="text-6-5-1">
-<div class="org-src-container">
-<pre class="src src-python"><span style="color: #b5bd68;">from</span> __init__ <span style="color: #b5bd68;">import</span> *
-
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create instance of Thread object with lambda func</span>
-<span style="color: #f0c674;">thread</span> = threading.Thread(target=<span style="color: #b5bd68;">lambda</span>:(
-time.sleep(<span style="color: #81a2be;">0.2</span>),
-<span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'this is from another thread'</span>)
-))
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">report thread alive status</span>
-is_alive = thread.is_alive()
-<span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'thread\'s </span>{is_alive=}<span style="color: #8abeb7;">'</span>)
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">report thread identifier value</span>
-ident = thread.ident
-<span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'</span>{ident=}<span style="color: #8abeb7;">'</span>)
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">report thread daemon property</span>
-daemon = thread.daemon
-<span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'</span>{daemon=}<span style="color: #8abeb7;">'</span>)
-name = thread.name
-<span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'</span>{name=}<span style="color: #8abeb7;">'</span>)
-thread.start()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">report thread native id property</span>
-native_id = thread.native_id
-<span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'</span>{native_id=}<span style="color: #8abeb7;">'</span>)
-is_alive = thread.is_alive()
-<span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'</span>{is_alive=}<span style="color: #8abeb7;">'</span>)
-ident = thread.ident
-<span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'</span>{ident=}<span style="color: #8abeb7;">'</span>)
-thread.join()
-is_alive = thread.is_alive()
-<span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'</span>{is_alive=}<span style="color: #8abeb7;">'</span>)
-
-</pre>
-</div>
-</div>
-</div>
-</div>
-</div>
-
-<div id="outline-container-orga449a90" class="outline-2">
-<h2 id="orga449a90"><span class="section-number-2">7.</span> configure threads</h2>
-<div class="outline-text-2" id="text-7">
-</div>
-<div id="outline-container-orgd774ae8" class="outline-3">
-<h3 id="orgd774ae8"><span class="section-number-3">7.1.</span> how to configure thread name</h3>
-<div class="outline-text-3" id="text-7-1">
-<p>
-the name of a thread can be ser via the <b>&ldquo;name&rdquo;</b> argument in the threading.Thread constructor
-</p>
-</div>
-</div>
-
-
-
-<div id="outline-container-orgf96bb6a" class="outline-3">
-<h3 id="orgf96bb6a"><span class="section-number-3">7.2.</span> how to configure thread daemon</h3>
-<div class="outline-text-3" id="text-7-2">
-<p>
-a thread may be configured to be a daemon or not,and most threads in concurrent programming,including the main thread,are non-daemon threads(no background threads) by default
-</p>
-
-<p>
-can be configured via setting <b>&ldquo;daemon&rdquo;</b> argument to True in the constructor
-</p>
-</div>
-
-<div id="outline-container-org3b975d2" class="outline-4">
-<h4 id="org3b975d2"><span class="section-number-4">7.2.1.</span> for example:</h4>
-<div class="outline-text-4" id="text-7-2-1">
-<div class="org-src-container">
-<pre class="src src-python"><span style="color: #b5bd68;">from</span> __init__ <span style="color: #b5bd68;">import</span> *
-<span style="color: #f0c674;">thread</span> = threading.Thread(name=<span style="color: #8abeb7;">'daemon Thread'</span>,daemon=<span style="color: #81a2be;">True</span>,target=<span style="color: #b5bd68;">lambda</span>:<span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'this message is from daemon thread'</span>))
-<span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'</span>{thread.daemon=}<span style="color: #8abeb7;">'</span>)
-<span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'</span>{thread.name=}<span style="color: #8abeb7;">'</span>)
-thread.start()
-</pre>
-</div>
-</div>
-</div>
-</div>
-</div>
-
-<div id="outline-container-org126819c" class="outline-2">
-<h2 id="org126819c"><span class="section-number-2">8.</span> whats main thread</h2>
-<div class="outline-text-2" id="text-8">
-<p>
-each python process is created with one default thread called the <b>&ldquo;the main thread&rdquo;</b>
-</p>
-
-<p>
-when we execute a python program, it is executing in the main thread.
-</p>
-
-<p>
-the main thread is created for each python process
-</p>
-
-<blockquote>
-<p>
-in normal conditions, the main thread is thread from which the python interpreter was started.
-</p>
-</blockquote>
-<p>
-&#x2013; <a href="https://docs.python.org/3/library/threading.html">threading &#x2013; Thread-based parallelism</a>
-</p>
-
-<p>
-the main thread in each python process always has the name <b>&ldquo;MainThread&rdquo;</b> and is not a daemon thread.Once the <b>&ldquo;main thread&rdquo;</b> exists,the Python will exit,assuming there are non-daemon threads running.
-</p>
-
-<blockquote>
-<p>
-there is a &ldquo;main thread&rdquo; object;this corresponds to initial thread of control in python program.It is not a daemon thread.
-</p>
-</blockquote>
-<p>
-&#x2013; <a href="https://docs.python.org/3/library/threading.html">threading &#x2013; Thread-based parallelism</a>
-</p>
-
-<p>
-we can acquire a main thread by calling <b>threadin.current<sub>thread</sub>()</b>
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python"><span style="color: #b5bd68;">from</span> __init__ <span style="color: #b5bd68;">import</span> *
-
-<span style="color: #b5bd68;">from</span> threading <span style="color: #b5bd68;">import</span> current_thread
-<span style="color: #f0c674;">thread</span> = current_thread()
-<span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'thread;\n</span>{thread.name=}<span style="color: #8abeb7;">,</span>{thread.daemon=}<span style="color: #8abeb7;">,</span>{thread.ident=}<span style="color: #8abeb7;">'</span>)
-</pre>
-</div>
-</div>
-</div>
-
-<div id="outline-container-orgf990e62" class="outline-2">
-<h2 id="orgf990e62"><span class="section-number-2">9.</span> Thread Utilities</h2>
-<div class="outline-text-2" id="text-9">
-</div>
-<div id="outline-container-org46cc125" class="outline-3">
-<h3 id="org46cc125"><span class="section-number-3">9.1.</span> number of active threads</h3>
-<div class="outline-text-3" id="text-9-1">
-<p>
-<b>threading.active<sub>count</sub>()</b> gives integer that indicates number of threads that are &ldquo;alive&rdquo;
-</p>
-</div>
-</div>
-
-<div id="outline-container-orgd82b10c" class="outline-3">
-<h3 id="orgd82b10c"><span class="section-number-3">9.2.</span> current thread</h3>
-<div class="outline-text-3" id="text-9-2">
-<p>
-<b>threading.current<sub>thread</sub>()</b> gives <b>threading.Thread</b> instance of thread running the current code
-</p>
-</div>
-</div>
-
-<div id="outline-container-orgf7db83d" class="outline-3">
-<h3 id="orgf7db83d"><span class="section-number-3">9.3.</span> thread identifier</h3>
-<div class="outline-text-3" id="text-9-3">
-<p>
-<b>threading.get<sub>ident</sub>()</b> gives current threads identifier integer
-</p>
-</div>
-</div>
-
-<div id="outline-container-org47a8693" class="outline-3">
-<h3 id="org47a8693"><span class="section-number-3">9.4.</span> native thread identifier</h3>
-<div class="outline-text-3" id="text-9-4">
-<p>
-<b>threading.get<sub>ident</sub>()</b> gives current threads identifier integer that assigned by operating system
-</p>
-</div>
-</div>
-
-<div id="outline-container-orgdab4b14" class="outline-3">
-<h3 id="orgdab4b14"><span class="section-number-3">9.5.</span> enumarate active threads</h3>
-<div class="outline-text-3" id="text-9-5">
-<p>
-we can get a list of active threads via calling <b>threading.enumarate()</b> function,it returns list of active threads
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python">
-<span style="color: #b5bd68;">from</span> __init__ <span style="color: #b5bd68;">import</span> *
-<span style="color: #f0c674;">active_thread_count</span> = threading.active_count()
-<span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'</span>{active_thread_count=}<span style="color: #8abeb7;">'</span>)
-current_thread = threading.current_thread()
-current_thread.name=<span style="color: #8abeb7;">"main thread"</span>
-<span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'</span>{current_thread=}<span style="color: #8abeb7;">'</span>)
-<span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'</span>{threading.get_ident()=}<span style="color: #8abeb7;">'</span>)
-thread = threading.Thread(name=<span style="color: #8abeb7;">'other thread'</span>,target=<span style="color: #b5bd68;">lambda</span>:<span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'this message is from daemon thread'</span>))
-<span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'</span>{threading.get_native_id()=}<span style="color: #8abeb7;">'</span>)
-thread.start()
-threads = threading.<span style="color: #b294bb;">enumerate</span>()
-<span style="color: #b5bd68;">for</span> th <span style="color: #b5bd68;">in</span> threads:
-    <span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'</span>{th.name=}<span style="color: #8abeb7;">'</span>)
-thread.join()
-
-</pre>
-</div>
-</div>
-</div>
-</div>
-
-<div id="outline-container-org9cf6454" class="outline-2">
-<h2 id="org9cf6454"><span class="section-number-2">10.</span> thread exception handling</h2>
-<div class="outline-text-2" id="text-10">
-</div>
-<div id="outline-container-org30352a6" class="outline-3">
-<h3 id="org30352a6"><span class="section-number-3">10.1.</span> unhandled exception</h3>
-<div class="outline-text-3" id="text-10-1">
-<p>
-an unhandled exception can occur in a new thread.
-</p>
-
-<p>
-the effect will be that the thread will unwind and report the message on standart
-error.Unwinding the thread means that the thread will stop executing at the point of the (or error) and that the exception will bubble up the stack in the thread until it reaches the top level,e.g. the run() funtion.
-</p>
-
-
-<div class="org-src-container">
-<pre class="src src-python"><span style="color: #b5bd68;">from</span> __init__ <span style="color: #b5bd68;">import</span> *
-
-<span style="color: #b5bd68;">def</span> <span style="color: #de935f;">work</span>():
-    <span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'working .'</span>,end=<span style="color: #8abeb7;">''</span>)
-    <span style="color: #b5bd68;">for</span> ti <span style="color: #b5bd68;">in</span> <span style="color: #b294bb;">range</span>(<span style="color: #81a2be;">10</span>):
-        time.sleep(<span style="color: #81a2be;">0.5</span>)
-        <span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'. .'</span>,end=<span style="color: #8abeb7;">''</span>)
-    <span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'..'</span>)
-    <span style="color: #b5bd68;">raise</span> <span style="color: #81a2be;">Exception</span>(<span style="color: #8abeb7;">'something bad happened'</span>)
-thread = threading.Thread(target=work)
-thread.start()
-thread.join()
-<span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'continuing on ...'</span>)
-time.sleep(<span style="color: #81a2be;">0.2</span>)
-<span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'finished'</span>)
-</pre>
-</div>
-</div>
-</div>
-
-<div id="outline-container-org9858b86" class="outline-3">
-<h3 id="org9858b86"><span class="section-number-3">10.2.</span> exception hook</h3>
-<div class="outline-text-3" id="text-10-2">
-<p>
-we can specify how to handle unhandled errors aand exceptions that occuur within new threads via the exception hook
-</p>
-
-<p>
-by default,there is no exception hook, in which case the <b><a href="https://docs.python.org/3/library/sys.html#sys.excepthook">sys.excepthook function</a></b>
-is called that reports the familiar message.
-</p>
-
-<p>
-first, we must define a function that takes a single argument that will be an instance of the <b>ExceptHookArgs</b> class,containing details of the exception and thread
-</p>
-</div>
-
-<div id="outline-container-orgfa903cb" class="outline-4">
-<h4 id="orgfa903cb"><span class="section-number-4">10.2.1.</span> example</h4>
-<div class="outline-text-4" id="text-10-2-1">
-<div class="org-src-container">
-<pre class="src src-python">
-<span style="color: #b5bd68;">from</span> __init__ <span style="color: #b5bd68;">import</span> *
-
-<span style="color: #b5bd68;">def</span> <span style="color: #de935f;">work</span>():
-    <span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'working .'</span>,end=<span style="color: #8abeb7;">''</span>)
-    <span style="color: #b5bd68;">for</span> ti <span style="color: #b5bd68;">in</span> <span style="color: #b294bb;">range</span>(<span style="color: #81a2be;">10</span>):
-        time.sleep(<span style="color: #81a2be;">0.5</span>)
-        <span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'. .'</span>,end=<span style="color: #8abeb7;">''</span>)
-    <span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'..'</span>)
-    <span style="color: #b5bd68;">raise</span> <span style="color: #81a2be;">Exception</span>(<span style="color: #8abeb7;">'something bad happened'</span>)
-<span style="color: #b5bd68;">def</span> <span style="color: #de935f;">custom_hook</span>(args):
-    <span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'thread failed:</span>{args.exc_value}<span style="color: #8abeb7;">'</span>)
-threading.excepthook = custom_hook
-thread = threading.Thread(target=work)
-thread.start()
-thread.join()
-<span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'continuing on ...'</span>)
-time.sleep(<span style="color: #81a2be;">0.2</span>)
-<span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'finished'</span>)
-</pre>
-</div>
-</div>
-</div>
-</div>
-</div>
-
-<div id="outline-container-org2190760" class="outline-2">
-<h2 id="org2190760"><span class="section-number-2">11.</span> limitation of threads in cpython</h2>
-<div class="outline-text-2" id="text-11">
-<p>
-python interpreter generally does not permit more than one thread to run at a time
-</p>
-
-<p>
-this is achieved via mutal exclusion (mutex) lock within interpreter that ensures that only one thread at a time can execute python bytecodes in python virtual machine .
-</p>
-
-<blockquote>
-<p>
-In CPython, due to the Global Interpreter Lock, only one thread can execute Python code at once (even though certain performance-oriented libraries might overcome this limitation).
-</p>
-</blockquote>
-<p>
-&#x2013; <a href="https://docs.python.org/3/library/threading.html">threading &#x2013; Thread-based parallelism</a>
-</p>
-
-<p>
-this lock is referred to as the <b>Global interpreter Lock</b> or <b>GIL</b> for short.
-</p>
-<blockquote>
-<p>
-In CPython, the global interpreter lock, or GIL, is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecodes at once. The GIL prevents race conditions and ensures thread safety.
-</p>
-</blockquote>
-<p>
-&#x2013; <a href="https://wiki.python.org/moin/GlobalInterpreterLock">GLOBAL INTERPRETER LOCK, PYTHON WIKI</a>
-</p>
-
-<p>
-this means that although we might write concurent code  with threads and run our code  on hardware with many CPU cores, we may not be able to execute our code in parallel
-</p>
-
-<p>
-there are some exceptions to this.
-</p>
-
-<p>
-specially, the <b>GIL</b> is released by the Python interpreter sometimes to allow other threads to run.
-</p>
-
-<p>
-such as when the thread is blocked ,such as performing IO with socket or file, or often if the thread is executing computationally intesive code in C library,like hashing bytes.
-</p>
-
-<blockquote>
-<p>
-Luckily, many potentially blocking or long-running operations, such as I/O, image processing, and NumPy number crunching, happen outside the GIL. Therefore it is only in multithreaded programs that spend a lot of time inside the GIL, interpreting CPython bytecode, that the GIL becomes a bottleneck.
-</p>
-</blockquote>
-<p>
-&#x2013; <a href="https://wiki.python.org/moin/GlobalInterpreterLock">GLOBAL INTERPRETER LOCK, PYTHON WIKI</a>
-</p>
-
-<p>
-therefore, although in most cases Cpython will prevent parallel execution of threads, it is allowed in some circumstances,these  circumstances represent the base use case for adopting threads in our python programs.
-</p>
-</div>
-</div>
-
-<div id="outline-container-orgf32c134" class="outline-2">
-<h2 id="orgf32c134"><span class="section-number-2">12.</span> when to use thread</h2>
-<div class="outline-text-2" id="text-12">
-<p>
-there are times when the GIL lock is released by the interpreter and we can achieve  parallel execution of our concurent code in python.
-</p>
-
-<p>
-<b>examples of when lock is released include:</b>
-</p>
-
-<ul class="org-ul">
-<li>when thread is performing blocking IO</li>
-
-<li>when a thread is executing C code  and explicitly releases</li>
-</ul>
-
-<p>
-<b>there are also ways of avoiding the lock entirely,such a:</b>
-</p>
-
-<ul class="org-ul">
-<li>using third-party interpreter to execute python code</li>
-</ul>
-</div>
-
-<div id="outline-container-orge84a97b" class="outline-3">
-<h3 id="orge84a97b"><span class="section-number-3">12.1.</span> use threads for blocking IO</h3>
-<div class="outline-text-3" id="text-12-1">
-<p>
-should use threads for IO bound tasks.
-</p>
-
-<p>
-an IO-bound task is a type of tash that involves reading from or writing to device, file, or socket connection.
-</p>
-
-<p>
-modern CPUs, like a 4GHz CPU, can execute 4 billion instructions per second, and you likely have more than one CPU core in your system.
-</p>
-
-<p>
-doing IO is very slow compared to the speed of CPUs.
-</p>
-
-<p>
-interacting with devices,reading  and writing files and socket connections involves calling instructions in your operating system ,which will wait for the operation to complete. If this operation is the main focus for your Cpu ,such as executing in the main thread of your python program,then your cpu is going to wait many milliseconds or even many seconds doing nothing.
-</p>
-
-<p>
-that is probably preventing billions of operations from executing.
-</p>
-
-<p>
-a thread performing an IO operation will block for the duration of the operation.While blocked,this signals to the operating system that a thread can be suspended and onether thread can execute, called a context switch.
-</p>
-
-<p>
-additonally, python interpreter will release the GIL when performing blocking IO operations,allowing other threads within the python process to execute.
-</p>
-
-<p>
-therefore, blocking IO provides an excellent use case for using threads in python.
-</p>
-
-<p>
-examples of blocking IO operations include:
-</p>
-
-<ul class="org-ul">
-<li>reading or writing a file from the hard drive.</li>
-
-<li>reading or writing to standart output, input or error(stdin,stdout,stderr).</li>
-
-<li>printing a document.</li>
-
-<li>reading or writing bytes on a socket connection with a server.</li>
-
-<li>downloading or uplading a file.</li>
-
-<li>query a server.</li>
-
-<li>query a database.</li>
-
-<li>taking a photo.</li>
-
-<li>everythin that includes disk write read</li>
-</ul>
-</div>
-</div>
-
-<div id="outline-container-org2e4df22" class="outline-3">
-<h3 id="org2e4df22"><span class="section-number-3">12.2.</span> use threads external c code (that realses the GIL)</h3>
-<div class="outline-text-3" id="text-12-2">
-<p>
-we may make function calls that themselves call down into a third-party C library.
-</p>
-
-<p>
-Often these function calls will realase the GIL as the C library being called will not interact with the intpreter.
-</p>
-
-<p>
-this provides an opputunity for other threads in the python process to run.
-</p>
-
-<p>
-<b>for example</b>,when using the &ldquo;<b>hash</b>&rdquo; module in python std library,the GIL is released when hashing the data via the <a href="https://docs.python.org/3/library/hashlib.html#hashlib.hash.update">hash.update() function</a>
-</p>
-
-<blockquote>
-<p>
-The Python GIL is released to allow other threads to run while hash updates on data larger than 2047 bytes is taking place when using hash algorithms supplied by OpenSSL.
-</p>
-</blockquote>
-<p>
-&#x2013; <a href="https://docs.python.org/3/library/hashlib.html">HASHLIB — SECURE HASHES AND MESSAGE DIGESTS</a>
-</p>
-
-<p>
-Another example is the NumPy library for managing arrays of data which will release the GIL when performing functions on arrays.
-</p>
-
-<blockquote>
-<p>
-The exceptions are few but important: while a thread is waiting for IO (for you to type something, say, or for something to come in the network) python releases the GIL so other threads can run. And, more importantly for us, while numpy is doing an array operation, python also releases the GIL.
-</p>
-</blockquote>
-<p>
-&#x2013; <a href="https://scipy-cookbook.readthedocs.io/items/ParallelProgramming.html">WRITE MULTITHREADED OR MULTIPROCESS CODE, SCIPY COOKBOOK</a>
-</p>
-</div>
-</div>
-
-<div id="outline-container-org3b32456" class="outline-3">
-<h3 id="org3b32456"><span class="section-number-3">12.3.</span> use threads with (some) third-party python interpreter</h3>
-<div class="outline-text-3" id="text-12-3">
-<p>
-there are alternate commericial and open source python interpreters that you can acquire and use to execute your python code.
-</p>
-
-<p>
-some python interpreters may implement a GIL and release it more or less than Cpython. Other interpreters remove the GIL entirely and allow multiple python concurent threads to execute in parallel.
-</p>
-</div>
-</div>
-</div>
-
-<div id="outline-container-org5bb2439" class="outline-2">
-<h2 id="org5bb2439"><span class="section-number-2">13.</span> threads blocking calls</h2>
-<div class="outline-text-2" id="text-13">
-<p>
-a blocking call is a function call that does not return until is complete.
-</p>
-
-<p>
-all normal functions are blocking calls.
-</p>
-
-<p>
-blocking call are calls to functions that will wait for a specific condition and signal to the operating system that nothing interesting going on while the thread is waiting.
-</p>
-
-<p>
-the os may notice that a thread is making a blocking function call and decide to context switch to another thread.
-</p>
-
-<p>
-you may recall that the os manages what threads should run and when to run them.it achieves this using a type of multitasking where a running thread is suspended and suspended thread is restored and continues running.This suspending and restoring of threads is called a context switch.
-</p>
-
-<p>
-the os prefers to context switch away from blocked threads, allowing non-blocked threads to run.
-</p>
-
-<p>
-this means if a thread makes a blocking function call,a call that waits, then it is likely to signal that the thread can be suspended and allow other threads to run.
-</p>
-
-<p>
-similarly, many function calls that we may traditionally think block may have non-blocking versions in modern non-blocking concurrency APIs, like asyncio.
-</p>
-
-<p>
-there are three types of blocking function calls you need to consider in concurrent programming, they are:
-</p>
-
-<ul class="org-ul">
-<li>blocking calls on concurent primitives</li>
-
-<li>blocking calls for IO</li>
-
-<li>blocking calls to sleep</li>
-</ul>
-</div>
-
-<div id="outline-container-org435eb62" class="outline-3">
-<h3 id="org435eb62"><span class="section-number-3">13.1.</span> blocking calls on concurrency primitives</h3>
-<div class="outline-text-3" id="text-13-1">
-<p>
-there are many blocking calls in concurrent programming
-</p>
-
-<p>
-common ways are;
-</p>
-
-<ul class="org-ul">
-<li>waiting for a lock,e.g. calling acquire() from &rsquo;threading.Lock&rsquo; class</li>
-<li>waiting to be notified,e.g. calling wait() from &rsquo;threading.Condition&rsquo; class</li>
-<li>waiting for a thread to terminate ,e.g. calling join() from &rsquo;threading.Thread&rsquo; class</li>
-<li>waiting for an event,e.g. calling wait() from &rsquo;threading.Event&rsquo; class</li>
-<li>waiting for a barrier,e.g. calling wait() from &rsquo;threading.Barrier&rsquo; class</li>
-</ul>
-</div>
-</div>
-
-<div id="outline-container-org9fee928" class="outline-3">
-<h3 id="org9fee928"><span class="section-number-3">13.2.</span> blocking calls for I/O</h3>
-<div class="outline-text-3" id="text-13-2">
-<p>
-conventionally,function calls that interact with I/O are mostly blocking calls.they are blocking in same sencse as blocking calls in concurency primitives
-the wait for the I/O device respond is another signal to operating system that the thread can be context switched.
-</p>
-
-<p>
-common examples are;
-</p>
-
-<ul class="org-ul">
-<li><b>hdd(hard disk drive)</b> :reading,writing,appending,renaming,deleting,.. files</li>
-<li><b>perpheral devices</b>    :mouse,keyboard,screen,printe,camera,serial device etc.</li>
-<li><b>database</b>             :sql queries</li>
-<li><b>internet</b>             :downloading,uplading,http requests,etc.
-<ul class="org-ul">
-<li><b>email</b>                :send,receieve,querry inbox,etc.</li>
-</ul></li>
-<li><b>and more,mostly other socket related things</b></li>
-</ul>
-
-<p>
-performing I/O operations with devices is typically very slow compared to CPU operations.
-</p>
-
-<p>
-the I/O with devices is coordinated by the operating system and the device.this means the operating system can gather or sen some bytes from or to device.this means operating system can gather or send some bytes from or to the device then context switch back to the blocking thread when needed allowing the function call to progress.
-</p>
-</div>
-</div>
-
-<div id="outline-container-orga891c22" class="outline-3">
-<h3 id="orga891c22"><span class="section-number-3">13.3.</span> blocking calls to sleep</h3>
-<div class="outline-text-3" id="text-13-3">
-<p>
-the sleep() function is a capability provided by the underlying operating system that we can make use of within our program.
-</p>
-
-<p>
-it is a blocking function call that pauses the thread to block for a fixed time in seconds.
-in cpython this can be achieved via <b>&rsquo;sleep(seconds)&rsquo;</b> function call from built-in <b>time</b> module
-</p>
-<div class="org-src-container">
-<pre class="src src-python">
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">sleep for 5 seconds</span>
-<span style="color: #b5bd68;">import</span> time
-...
-time.sleep(<span style="color: #81a2be;">5</span>)
-...
-</pre>
-</div>
-<p>
-it is a blocking call it signals to the operating system that the thread is waiting and is a good candidate for a context switch.
-</p>
-
-<p>
-sleeps are often ısed when timing is important in an application.
-</p>
-
-<p>
-in programming, adding a sleep can be useful way to simulate waiting within fixed interval.
-</p>
-
-<p>
-sleep often used in worked examples when demonstrating concurrency programming,but adding sleeps to code can also aid in unit testing and debugging concurency failure conditions,such as race conditions by forcing mistiming of events within a dynamic application
-</p>
-</div>
-</div>
-</div>
-
-<div id="outline-container-org1cae294" class="outline-2">
-<h2 id="org1cae294"><span class="section-number-2">14.</span> thread-local data</h2>
-<div class="outline-text-2" id="text-14">
-<p>
-threads can store local data via an instance of the <b>threading.local</b> class
-</p>
-
-<p>
-example
-</p>
-<div class="org-src-container">
-<pre class="src src-python"><span style="color: #b5bd68;">import</span> threading
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create a instance of local class</span>
-
-<span style="color: #f0c674;">local</span> = threading.local()
-
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">store some data</span>
-local.<span style="color: #f0c674;">custom</span> = <span style="color: #81a2be;">33</span>
-</pre>
-</div>
-
-<p>
-importantly,other threads can use the same property names on local but the values will be limited to each thread.
-this is like a namespace limited to each thread and is called &ldquo;thread-local data&rdquo;.it means that threads cannot acces or read the local data of other threads.
-importantly, each thread must hang on to the &ldquo;local&rdquo; instance in order to acces the stored data.
-</p>
-</div>
-
-<div id="outline-container-org426f46c" class="outline-3">
-<h3 id="org426f46c"><span class="section-number-3">14.1.</span> example</h3>
-<div class="outline-text-3" id="text-14-1">
-<div class="org-src-container">
-<pre class="src src-python">
-<span style="color: #b5bd68;">from</span> __init__ <span style="color: #b5bd68;">import</span> *
-
-<span style="color: #b5bd68;">def</span> <span style="color: #de935f;">task</span>(<span style="color: #f0c674;">value</span>:<span style="color: #b294bb;">int</span>):
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create local storage</span>
-    local=threading.local()
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">store value in local storage</span>
-    local.<span style="color: #f0c674;">value</span> = value
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">block for given time</span>
-    time.sleep(value)
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">retrieve given value</span>
-    <span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'stored value: </span>{local.value}<span style="color: #8abeb7;">'</span>)
-
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create thread and start thread</span>
-threading.Thread(target=task,args=(<span style="color: #81a2be;">1</span>,)).start()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create another thread and start it</span>
-threading.Thread(target=task,args=(<span style="color: #81a2be;">2</span>,)).start()
-</pre>
-</div>
-</div>
-</div>
-</div>
-
-<div id="outline-container-orgcd19a6f" class="outline-2">
-<h2 id="orgcd19a6f"><span class="section-number-2">15.</span> thread mutex lock - <i>threading.Lock</i></h2>
-<div class="outline-text-2" id="text-15">
-</div>
-<div id="outline-container-orgd956ce3" class="outline-3">
-<h3 id="orgd956ce3"><span class="section-number-3">15.1.</span> what is mutual exclusion lock</h3>
-<div class="outline-text-3" id="text-15-1">
-</div>
-<div id="outline-container-orgc25a9ea" class="outline-4">
-<h4 id="orgc25a9ea"><span class="section-number-4">15.1.1.</span> why we need mutual exclusion lock</h4>
-<div class="outline-text-4" id="text-15-1-1">
-<div class="org-center">
-<p>
-a <span class="underline">mutual exclusion lock</span> is a synchronization primitive intented to prevent a race condition.
-</p>
-
-<p>
-a race conditions is a concurency failure case when two threads run same code and access or update same resource leaving the resource unkown and inconsistent state.
-these censitive parts of cade that can be executed by multiple threads concurently and may result in race conditions are called critical sections, a critical
-section may refer to single block of code, but is also refers to multiple accesses to the same data variable or resource from multiple functions.
-</p>
-</div>
-</div>
-</div>
-<div id="outline-container-orgaf8ea4d" class="outline-4">
-<h4 id="orgaf8ea4d"><span class="section-number-4">15.1.2.</span> description of mutex</h4>
-<div class="outline-text-4" id="text-15-1-2">
-<div class="org-center">
-<p>
-mutual exclusion lock also known as mutex,is synchronization mechanism used to control acces to a shared resource in concurent system.A mutex is essentially a binary semaphore (e.g railroad switch signals) with two states;locked and unlocked.When a thread acquires a mutex,it sets the lock to locked state,preventing other threads from also acquiring the lock.The thread that acquire the lock is said to have exclusive acces to the shared resource.When the thread releases the lock.The thread that acquired the lock is said to gave exclusive access to the shared resource.When the thread releases the lock,it sets the lock to the unlocked state, allowing other thread to acquire the lock and gain access to the shared resource.this mechanism ensures that only one thread can access resource at a time, preventing race conditions and other synchronization issues.
-</p>
-</div>
-</div>
-</div>
-</div>
-<div id="outline-container-orgcb425b7" class="outline-3">
-<h3 id="orgcb425b7"><span class="section-number-3">15.2.</span> how to use mutex lock</h3>
-<div class="outline-text-3" id="text-15-2">
-<div class="org-center">
-<p>
-the class implementing primitive lock objects.
-</p>
-
-<p>
-NOTE : that <span class="underline">Lock</span> is actually a factory function which returns an instance of the most efficient version of the concrete Lock class that is supported by the platform
-</p>
-</div>
-
-
-<div class="org-src-container">
-<pre class="src src-python"><span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create a lock</span>
-<span style="color: #f0c674;">lock</span> = threading.Lock()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">acquire the lock</span>
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">...</span>
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">release the lock</span>
-lock.release()
-</pre>
-</div>
-<p>
-only one thread can acquire lock,if lock not released it cannot be acquired again.
-</p>
-
-<p>
-the thread attempting to acquire the lock will block until the lock is acquired, such as if another thread currently holds the lock then releases it.
-</p>
-
-<p>
-we can attempt to acquire the lock without blocking by setting the &ldquo;blocking&rdquo; arg to <b>False</b>. if the lock cannot be acquired,a value of <b>False</b> is returned.
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">acquire the lock without blocking</span>
-lock.acquire(blocking=false)
-</pre>
-</div>
-
-<p>
-we can also attempt to acquire the lock with a timeout,If the lock cannot be acquired a <b>False</b> returned.
-</p>
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">acquire the lock with a timeout</span>
-lock.acquire(timeout=<span style="color: #81a2be;">10</span>)
-</pre>
-</div>
-</div>
-
-<div id="outline-container-org3102e11" class="outline-4">
-<h4 id="org3102e11"><span class="section-number-4">15.2.1.</span> for example</h4>
-<div class="outline-text-4" id="text-15-2-1">
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create a lock</span>
-<span style="color: #f0c674;">lock</span> = threading.Lock()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">acquire the lock</span>
-<span style="color: #b5bd68;">with</span> lock:
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">...</span>
-</pre>
-</div>
-
-<p>
-this is preffered usage as it makes it clear where the protected code starts and ends,and ensures that the lock is always released, even if there is an exception or error within the critical section.
-</p>
-
-<p>
-also we can check if the lock is currently acquired by a thread
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python"><span style="color: #b5bd68;">if</span> lock.locked():
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">if lock is acquired runs this indent block of code</span>
-<span style="color: #b5bd68;">else</span>:
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">if not lock is acquired runs this indent block of code</span>
-</pre>
-</div>
-</div>
-</div>
-</div>
-
-<div id="outline-container-org73d3c2b" class="outline-3">
-<h3 id="org73d3c2b"><span class="section-number-3">15.3.</span> example of using mutex lock</h3>
-<div class="outline-text-3" id="text-15-3">
-<div class="org-src-container">
-<pre class="src src-python">
-<span style="color: #b5bd68;">from</span> __init__ <span style="color: #b5bd68;">import</span> *
-<span style="color: #b5bd68;">from</span> random <span style="color: #b5bd68;">import</span> random
-
-<span style="color: #b5bd68;">def</span> <span style="color: #de935f;">task</span>(lock,identifier,value:<span style="color: #b294bb;">int</span>|<span style="color: #b294bb;">float</span>):
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">acquire the lock</span>
-    <span style="color: #b5bd68;">with</span> lock:
-        <span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'&gt;thread </span>{identifier}<span style="color: #8abeb7;"> got the lock,sleepin for </span>{value}<span style="color: #8abeb7;">'</span>)
-        time.sleep(value)
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create shared lock</span>
-<span style="color: #f0c674;">lock</span> = threading.Lock()
-<span style="color: #b5bd68;">for</span> i <span style="color: #b5bd68;">in</span> <span style="color: #b294bb;">range</span>(<span style="color: #81a2be;">10</span>):
-    threading.Thread(target=task, args=(lock, i, random())).start()
-
-</pre>
-</div>
-</div>
-</div>
-</div>
-
-<div id="outline-container-orgc3e8867" class="outline-2">
-<h2 id="orgc3e8867"><span class="section-number-2">16.</span> thread reentrant lock  - <i>threading.RLock</i></h2>
-<div class="outline-text-2" id="text-16">
-</div>
-<div id="outline-container-org295fc45" class="outline-3">
-<h3 id="org295fc45"><span class="section-number-3">16.1.</span> what is reentrant lock</h3>
-<div class="outline-text-3" id="text-16-1">
-<p>
-a reentrant mutual exclusion lock aka &ldquo;reenrant mutex&rdquo; or &ldquo;reentrant lock&rdquo; for short, is like a mutex lock except it allows a thread to acquire the lock more than once.
-</p>
-<blockquote>
-<p>
-a reentrant lock is synchranization primitive that may be acquired multiple times by the same thread [&#x2026;] In the locked state,some thread owns the lock;in the unlocked state no thread owns it
-</p>
-</blockquote>
-<p>
-&#x2013; <a href="https://docs.python.org/3/library/threading.html#rlock-objects.html">rlock objects &#x2013; Thread-based parallelism</a>
-</p>
-</div>
-<div id="outline-container-org8c510c6" class="outline-4">
-<h4 id="org8c510c6"><span class="section-number-4">16.1.1.</span> why we neet reentrant lock</h4>
-<div class="outline-text-4" id="text-16-1-1">
-<p>
-we can imagine critical sections spread across a number of funcstions,each protected by the same lock.A thread may call across these functions in course of normal execution and may call into one critical section from another critical section.
-</p>
-
-<p>
-a limitation of a (non-reentrant) mutex lock is that if a thread has acquired the lock that it cannot acquire it again.In fact, this situation will result in a deadblock as it will wait forever for the lock to be released so that it can be acquired, but it holds the lock and will not release it.
-</p>
-</div>
-</div>
-
-<div id="outline-container-orge5fb020" class="outline-4">
-<h4 id="orge5fb020"><span class="section-number-4">16.1.2.</span> description of reentrant lock</h4>
-<div class="outline-text-4" id="text-16-1-2">
-<p>
-a reenrant lock will allow a thread to acquire the same lock again if it has already acquired it.This allows the thread to execute critical sections from within critical sections,as long as they are protected by same reentrant lock.
-</p>
-
-<p>
-each time a thread acquires the lock it must also release it, meaning that are recursive levels of acquire and release for the owning thread.As such,this type of lock is sometimes called a &ldquo;recursive mutex lock&rdquo;.
-</p>
-</div>
-</div>
-</div>
-
-<div id="outline-container-org629285b" class="outline-3">
-<h3 id="org629285b"><span class="section-number-3">16.2.</span> how to use reentrant lock</h3>
-<div class="outline-text-3" id="text-16-2">
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create reentrant lock</span>
-<span style="color: #f0c674;">lock</span> = RLock()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">acquires the lock</span>
-lock.acquire()
-...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">release the lock</span>
-lock.release()
-</pre>
-</div>
-
-<p>
-the thread attempting to acquire the lock will block until the lock is acquired, such as if another thread currently holds the lock (once or more than once) then releases it.
-</p>
-
-<p>
-we can use &ldquo;<b>blocking</b>&rdquo; argument and &ldquo;<b>timeout</b>&rdquo; argument like normal mutex lock.
-bonus: we can use via &rsquo;<b>with</b>&rsquo; keyword for safety.
-</p>
-</div>
-</div>
-
-<div id="outline-container-org7ff72d9" class="outline-3">
-<h3 id="org7ff72d9"><span class="section-number-3">16.3.</span> example of using reentrant lock</h3>
-<div class="outline-text-3" id="text-16-3">
-<div class="org-src-container">
-<pre class="src src-python">
-<span style="color: #b5bd68;">from</span> __init__ <span style="color: #b5bd68;">import</span> *
-<span style="color: #b5bd68;">from</span> random <span style="color: #b5bd68;">import</span> random
-
-<span style="color: #b5bd68;">def</span> <span style="color: #de935f;">report</span>(lock,identifier):
-    <span style="color: #b5bd68;">with</span> lock:
-        <span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'&gt;thread </span>{identifier}<span style="color: #8abeb7;"> done'</span>)
-
-<span style="color: #b5bd68;">def</span> <span style="color: #de935f;">task</span>(lock,identifier,value):
-    <span style="color: #b5bd68;">with</span> lock:
-        <span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'&gt; thread </span>{identifier}<span style="color: #8abeb7;"> sleeping for </span>{value}<span style="color: #8abeb7;">'</span>)
-        time.sleep(value)
-        report(lock,identifier)
-<span style="color: #f0c674;">lock</span> = threading.RLock()
-<span style="color: #b5bd68;">for</span> i <span style="color: #b5bd68;">in</span> <span style="color: #b294bb;">range</span>(<span style="color: #81a2be;">10</span>):
-    threading.Thread(target=task,args=(lock,i,random())).start()
-
-</pre>
-</div>
-
-<p>
-running the examples creates 10 threads with target as task function.
-then executes them.only one thread can acquire the lock at time,and then once acquired,blocks and then reenters the same lock again to report the done message.
-</p>
-
-<p>
-if non-reentrant lock,e.g. a threading.Lock was used instead,then the thread would block forever waiting for the lock to become available,which it can&rsquo;t because the thread already holds the lock.
-</p>
-</div>
-</div>
-</div>
-<div id="outline-container-orga6e7ff5" class="outline-2">
-<h2 id="orga6e7ff5"><span class="section-number-2">17.</span> thread condition - <i>threading.Condition</i></h2>
-<div class="outline-text-2" id="text-17">
-</div>
-<div id="outline-container-org0b38af1" class="outline-3">
-<h3 id="org0b38af1"><span class="section-number-3">17.1.</span> what is a threading condition</h3>
-<div class="outline-text-3" id="text-17-1">
-<p>
-in concurency,a condition (also called a monitor) allows multiple threads to be notified about some result.
-</p>
-
-<p>
-it combines both a mutual exclusion lock(mutex) and a conditional variable.
-</p>
-
-<p>
-a mutex allow can be used to protect a critical section, but it cannot be used to alert other threads that a condition has changed or been met.
-</p>
-
-<p>
-a condition can be acquired by a thread(like a mutex) after which it canbe wait to be notified by another thread that something has changed. while waiting, the thread is blocked and releases the lock for other threads to acquire.
-</p>
-
-<p>
-another thread can then acquire the condition, make change, and notify one, all, or a subset of threads waiting on the condition that something has changed. the waiting thread can then wake-up (be scheduled by the op. sys.), reacquire the condition  (mutex), perform checks on any changed state and perform required actions.
-</p>
-
-<p>
-this highlights that a condition and to allow threads to notify other threads waiting on the condition.
-</p>
-</div>
-</div>
-
-<div id="outline-container-org7b78541" class="outline-3">
-<h3 id="org7b78541"><span class="section-number-3">17.2.</span> how to use condition object</h3>
-<div class="outline-text-3" id="text-17-2">
-<p>
-we can create condition object by default it will create a new reentrant mutex lock (<b>threading.RLock</b>).
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create a new condition</span>
-
-<span style="color: #f0c674;">condition</span> = threading.Condition()
-
-</pre>
-</div>
-
-<p>
-we may have a reentrant or non-reentrant mutex that we wish to reuse in the condition for some good reason, in which case we can provide it to the constructor.
-</p>
-
-<p>
-this is unrecommended unless you know your use case has this requirement.The chance of getting into trouble is high.
-</p>
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create a new condition with custom lock</span>
-
-<span style="color: #f0c674;">condition</span> = threading.Condition(lock=my_lock)
-
-</pre>
-</div>
-
-<p>
-<b>we can aquire and release conditions like the Locks</b>
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">acquire the condition</span>
-condition.acquire()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">wait to be notified</span>
-condition.wait()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">release the condition</span>
-condition.release()
-
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">alternate way of doing same things</span>
-
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">acquire the condition</span>
-<span style="color: #b5bd68;">with</span> condition:
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">wait to be notified</span>
-    condition.wait()
-</pre>
-</div>
-
-<p>
-we can notify a single waitinh thread viaa the notify function.
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">acquire the condition</span>
-<span style="color: #b5bd68;">with</span> condition:
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">notify a waiting thread</span>
-    condition.notify()
-...
-
-</pre>
-</div>
-
-<p>
-the notified thread will stop-blocking as soon as it can re-acquire the mutex within condition.This will be attemted automatically as part of its call to wait(), you do not need to do anything extra.
-</p>
-
-<p>
-if there are more than one thread waiting on the condition, we will not know which thread will be notified.
-</p>
-
-<p>
-we can notify all threads waitinh on yhe condition via the notify<sub>all</sub>() function.
-</p>
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">acquire the condition</span>
-<span style="color: #b5bd68;">with</span> condition:
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">notify all threads waiting on the condition</span>
-    condition.notify_all()
-...
-
-</pre>
-</div>
-</div>
-</div>
-
-<div id="outline-container-orgf37a8fb" class="outline-3">
-<h3 id="orgf37a8fb"><span class="section-number-3">17.3.</span> example of wait and notify with a condition</h3>
-<div class="outline-text-3" id="text-17-3">
-<div class="org-src-container">
-<pre class="src src-python"><span style="color: #b5bd68;">from</span> __init__ <span style="color: #b5bd68;">import</span> *
-
-<span style="color: #b5bd68;">def</span> <span style="color: #de935f;">task</span>(condition, work_list):
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">block for a moment</span>
-    time.sleep(<span style="color: #81a2be;">1</span>)
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">add data to the work list</span>
-    work_list.append(<span style="color: #81a2be;">2</span>)
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">notify a waiting thread that work is done</span>
-    <span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'thread sending notif...'</span>)
-    <span style="color: #b5bd68;">with</span> <span style="color: #f0c674;">condition</span>:
-        condition.notify()
-
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create a condition</span>
-condition = threading.Condition()
-<span style="color: #f0c674;">work_list</span> = <span style="color: #b294bb;">list</span>()
-<span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'main thread waiting for data ...'</span>)
-<span style="color: #b5bd68;">with</span> <span style="color: #f0c674;">condition</span>:
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">start a new thread to perform some work</span>
-    worker = threading.Thread(target=task, args=(condition,work_list))
-    worker.start()
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">wait to be notified</span>
-    condition.wait()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">we know the data is ready</span>
-<span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'got data: </span>{work_list}<span style="color: #8abeb7;">'</span>)
-</pre>
-</div>
-</div>
-</div>
-</div>
-
-<div id="outline-container-orgee91dc8" class="outline-2">
-<h2 id="orgee91dc8"><span class="section-number-2">18.</span> thread semaphore - <i>threading.Semaphore</i></h2>
-<div class="outline-text-2" id="text-18">
-<p>
-a semaphore is essentially a counter protected by a mutex lock used to limit the number of threads that can acces a resource.
-</p>
-</div>
-
-<div id="outline-container-org9d6be22" class="outline-3">
-<h3 id="org9d6be22"><span class="section-number-3">18.1.</span> what is a semaphore</h3>
-<div class="outline-text-3" id="text-18-1">
-<p>
-a semaphore is a concurency primitive that allows a limit on the number of threads that can acquire a lock protecting a critical section.
-</p>
-
-<p>
-it is an extension of a mutual exclusion (mutex) lock that adds a count for the number of threads that can acquire the lock before additional threads will block. once full, new threads can only acquire a position on the semaphore once existing thread holding the semaphore releases a position.
-</p>
-
-<p>
-internally, the semaphore maintains a counter protected by a mutex lock that is incremented each time the semphore is acquired and decremented each time it released.
-</p>
-
-<p>
-when semaphore is created, the upper limit on the counter is set. If it is set to be 1, then the semphore will operate like a mutex lock.
-</p>
-
-<p>
-A semaphore provides a useful concurency, in examples:
-</p>
-<ul class="org-ul">
-<li>limiting concurent;
-<ul class="org-ul">
-<li>socket connections to a server.</li>
-<li>file operations on a hard drive.</li>
-<li>calculations</li>
-</ul></li>
-</ul>
-</div>
-</div>
-
-<div id="outline-container-org67e18a6" class="outline-3">
-<h3 id="org67e18a6"><span class="section-number-3">18.2.</span> how to use a semaphore</h3>
-<div class="outline-text-3" id="text-18-2">
-<p>
-the <b>threading.Semaphore</b> instance must be configured when it is created to set the limit on the internal counter.This limit will match the number of concurrent threads that can hold the semaphore.
-</p>
-
-<p>
-in example
-</p>
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create a semaphore with a limit of 100</span>
-<span style="color: #f0c674;">semaphore</span> = Semaphore(<span style="color: #81a2be;">100</span>)
-</pre>
-</div>
-
-<p>
-in this implementation,each time the semaphore is acquired,the internal counter is decremented. each time the semaphore is released, the internal counter is incremented.The semephore cannot be acquired if the semphore has no avaliable positions in which case, threads attempting to acquire it must block until a postion becomes avaliable.
-</p>
-</div>
-
-<div id="outline-container-org177adf7" class="outline-4">
-<h4 id="org177adf7"><span class="section-number-4">18.2.1.</span> acquiring and releasing</h4>
-<div class="outline-text-4" id="text-18-2-1">
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">acquire the semphore without blocking</span>
-semphore.acquire(blocking=<span style="color: #81a2be;">False</span>)
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">acquire the semaphore with a timeout</span>
-semaphore.acquire(timeout=<span style="color: #81a2be;">19</span>)
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">release the semaphore</span>
-semaphore.release()
-
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">acquire the semphore</span>
-<span style="color: #b5bd68;">with</span> semphore:
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">...</span>
-</pre>
-</div>
-</div>
-</div>
-</div>
-
-<div id="outline-container-org381d49a" class="outline-3">
-<h3 id="org381d49a"><span class="section-number-3">18.3.</span> example</h3>
-<div class="outline-text-3" id="text-18-3">
-<div class="org-src-container">
-<pre class="src src-python"><span style="color: #b5bd68;">from</span> __init__ <span style="color: #b5bd68;">import</span> *
-<span style="color: #b5bd68;">from</span> random <span style="color: #b5bd68;">import</span> random
-
-<span style="color: #b5bd68;">def</span> <span style="color: #de935f;">task</span>(semaphore, <span style="color: #f0c674;">number</span>:<span style="color: #b294bb;">int</span>):
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">attempt to acquire the semaphore</span>
-    <span style="color: #b5bd68;">with</span> semaphore:
-        <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">process</span>
-        value = random()
-        time.sleep(value)
-        <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">report result</span>
-        <span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'thread </span>{number}<span style="color: #8abeb7;"> got </span>{value}<span style="color: #8abeb7;">'</span>)
-
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create a semaphore</span>
-<span style="color: #f0c674;">semaphore</span> = threading.Semaphore()
-<span style="color: #b5bd68;">for</span> i <span style="color: #b5bd68;">in</span> <span style="color: #b294bb;">range</span>(<span style="color: #81a2be;">10</span>):
-    <span style="color: #f0c674;">worker</span> = threading.Thread(target=task,args=(semaphore, i))
-    worker.start()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">wait for all workers to complete ...</span>
-
-</pre>
-</div>
-</div>
-</div>
-</div>
-
-<div id="outline-container-org1b5c80e" class="outline-2">
-<h2 id="org1b5c80e"><span class="section-number-2">19.</span> thread event - <i>threading.Event</i></h2>
-<div class="outline-text-2" id="text-19">
-<p>
-an event is a thread-safe boolean flag.
-</p>
-</div>
-<div id="outline-container-org2e843aa" class="outline-3">
-<h3 id="org2e843aa"><span class="section-number-3">19.1.</span> how to use event object</h3>
-<div class="outline-text-3" id="text-19-1">
-<p>
-an event is a simple pritimitve that allows communitcation between threads.
-</p>
-
-<p>
-a <b>threading.Event</b> object wraps a boolean variable that can either be &ldquo;set&rdquo; (<b>True</b>) or &ldquo;not set&rdquo; (<b>False</b>). threads sharing the event instance can check if the event is set and set the event or clear event (make it not set), or wait for the event to be set.
-</p>
-
-<p>
-the <b>threading.Event</b> provides an easy way to share a boolean variable between threads that can act as a trigger for an action.
-</p>
-
-<blockquote>
-<p>
-this is one of the simplest mechanism for communitcation between threads: one thread signals an event and other threads wait for it.
-</p>
-</blockquote>
-
-<p>
-&#x2013; <a href="https://docs.python.org/3/library/threading.html#event-objects">Event objects,threading &#x2013; thread-based parallelism</a>
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create an instance of an event</span>
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">! and the event will be in the "not set" state.</span>
-<span style="color: #f0c674;">event</span> = threading.Event()
-
-...
-
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">check if the event is set</span>
-<span style="color: #b5bd68;">if</span> event.is_set():
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">do something ...</span>
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">set the event</span>
-event.<span style="color: #b294bb;">set</span>()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">mark the event as not sets</span>
-event.clear()
-
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">wait for the event to be sets</span>
-event.wait()
-</pre>
-</div>
-
-<div class="org-center">
-<p>
-NOTE ⚠: waiting threads are only notified when <b>set()</b> function is called, not when <b>clear()</b> function is called
-</p>
-</div>
-
-<p>
-a &ldquo;<b>timeout</b>&rdquo; argument can be passed to the <b>wait()</b> function which will limit how long a thread will return True if the event was set while waiting, otherwise a value <b>False</b> returned indicates that the event was not set and called timedout.
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">wait for the event to be set with a timeout</span>
-event.wait(timeout=<span style="color: #81a2be;">10</span>)
-</pre>
-</div>
-</div>
-</div>
-
-<div id="outline-container-orgd456f71" class="outline-3">
-<h3 id="orgd456f71"><span class="section-number-3">19.2.</span> example</h3>
-<div class="outline-text-3" id="text-19-2">
-<div class="org-src-container">
-<pre class="src src-python"><span style="color: #b5bd68;">from</span> __init__ <span style="color: #b5bd68;">import</span> *
-<span style="color: #b5bd68;">from</span> random <span style="color: #b5bd68;">import</span> random
-
-<span style="color: #b5bd68;">def</span> <span style="color: #de935f;">task</span>(event, number):
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">wait for the event to be set</span>
-    event.wait()
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">begin processing</span>
-    <span style="color: #f0c674;">value</span> = random()
-    time.sleep(value)
-    <span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'thread </span>{number}<span style="color: #8abeb7;"> got </span>{value}<span style="color: #8abeb7;">'</span>)
-
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create a shared event object</span>
-<span style="color: #f0c674;">event</span> = threading.Event()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create a suite of threads</span>
-<span style="color: #b5bd68;">for</span> i <span style="color: #b5bd68;">in</span> <span style="color: #b294bb;">range</span>(<span style="color: #81a2be;">5</span>):
-    <span style="color: #f0c674;">thread</span> = threading.Thread(target=task,args=(event,i))
-    thread.start()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">block for a moment</span>
-<span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">' main thread blocking ...'</span>)
-time.sleep(<span style="color: #81a2be;">2</span>)
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">start processing in all threads</span>
-event.<span style="color: #b294bb;">set</span>()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">wait for all threads to finnish ...</span>
-</pre>
-</div>
-</div>
-</div>
-</div>
-<div id="outline-container-orgba6e4f7" class="outline-2">
-<h2 id="orgba6e4f7"><span class="section-number-2">20.</span> timer threads - <i>threading.Timer</i></h2>
-<div class="outline-text-2" id="text-20">
-<p>
-a timer thread will execute a function after a time delay.
-</p>
-</div>
-<div id="outline-container-org94d3852" class="outline-3">
-<h3 id="org94d3852"><span class="section-number-3">20.1.</span> how to use a timer thread</h3>
-<div class="outline-text-3" id="text-20-1">
-<p>
-the <b>threading.Timer</b> is an extension of fhe <b>threading.Thread</b> class because of this reason
-we can use it just like a normal thread instance.
-</p>
-
-<p>
-first, we can create an instance of the timer and configure it.This includes the time to wait before executing in seconds, the function to execute once triggered, adn any arguments to the target function.
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create with configuration a timer  thread</span>
-<span style="color: #f0c674;">timerT</span> = threading.Timer(<span style="color: #81a2be;">10</span>,task,args=(arg1,arg2))
-
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">to start timer func we use</span>
-timerT.start()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">if we decide cancel the timer before target function has executed,we can use timerthread's cancel() method</span>
-
-timerT.cancel()
-</pre>
-</div>
-</div>
-</div>
-
-<div id="outline-container-org35cc1f6" class="outline-3">
-<h3 id="org35cc1f6"><span class="section-number-3">20.2.</span> example of using a timer thread</h3>
-<div class="outline-text-3" id="text-20-2">
-<div class="org-src-container">
-<pre class="src src-python"><span style="color: #b5bd68;">from</span> __init__ <span style="color: #b5bd68;">import</span> *
-
-<span style="color: #b5bd68;">def</span> <span style="color: #de935f;">task</span>(message):
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">report the message</span>
-    <span style="color: #b294bb;">print</span>(message)
-
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create a thread timer object</span>
-<span style="color: #f0c674;">timerT</span> = threading.Timer(<span style="color: #81a2be;">3</span>, task, args=(<span style="color: #8abeb7;">'hello world'</span>,))
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">start the timer object</span>
-timerT.start()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">wait for the timer to finish</span>
-<span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'waiting for the timer ...'</span>)
-</pre>
-</div>
-</div>
-</div>
-</div>
-
-<div id="outline-container-org01509ca" class="outline-2">
-<h2 id="org01509ca"><span class="section-number-2">21.</span> thread barrier - <i>threading.Barrier</i></h2>
-<div class="outline-text-2" id="text-21">
-</div>
-<div id="outline-container-orgb196bd1" class="outline-3">
-<h3 id="orgb196bd1"><span class="section-number-3">21.1.</span> what is barrier</h3>
-<div class="outline-text-3" id="text-21-1">
-<p>
-a barrier is a synchranization primitive.
-</p>
-
-<p>
-it allows multiple threads to wait on the same barrier object instance (e.g. at the same point in code) until a predefined fixed number of threads arrive (e.g. barrier is full), after which all threads are then notified and released to continue their execution.
-</p>
-
-<p>
-internally, a barrier maintains a count of the number of threads waiting on the barrier and a configured maximum number of parties (threads) that are expected. Once the expected number of parties reaches the pre-defined maximum, all waiting threads are notified.
-</p>
-</div>
-</div>
-<div id="outline-container-orgc3226d4" class="outline-3">
-<h3 id="orgc3226d4"><span class="section-number-3">21.2.</span> how to use barrier</h3>
-<div class="outline-text-3" id="text-21-2">
-<p>
-a barrier instance must first be created and configured via the constructor specifying the number of parties (threads) that must arrive before the barrier will be lifted.
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create a barrier</span>
-<span style="color: #f0c674;">Tbarrier</span> = threading.Barrier(<span style="color: #81a2be;">10</span>)
-</pre>
-</div>
-
-<p>
-we can also perform an action once all threads reach the barrier which can be specified via &ldquo;action&rdquo; arg in the constructor.
-</p>
-
-<p>
-this action mus be callable such as a function or a lambda that does not take any arguments and will be executed by one thread once all threads reach the barrier and call the <b>wait()</b> function.
-</p>
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #f0c674;">Tbarrier</span> = threading.Barrier(<span style="color: #81a2be;">10</span>,action=my_func)
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">we can use timeout too</span>
-Tbarrier = threading.Barrier(<span style="color: #81a2be;">10</span>,action=my_func,timedout=<span style="color: #81a2be;">5</span>)
-Tbarrier = threading.Barrier(<span style="color: #81a2be;">10</span>,timedout=<span style="color: #81a2be;">5</span>)
-</pre>
-</div>
-
-<p>
-a thread can reach and wait on the barrier via the <b>wait()</b> function.
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">wait on the barrier for all other threads to arrive</span>
-barrier.wait()
-</pre>
-</div>
-
-<p>
-this iss a blocking call and will return once all other threads (the pre-configured number of parties) have reached the barrier.
-</p>
-
-<p>
-the wait function does return an integer indicating the number of parties remaining to arrive at the barrier.If a thread was the last thread to arrive, then the return value will be zero.This is helpful if you want the last thread or one thread to perform an action after the barrier is released, and alternative to using the &ldquo;<b>action</b>&rdquo; arg in constructor.
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">wait on the barrier</span>
-<span style="color: #f0c674;">remaining</span> = barrier.wait()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">after released, check if this was the last party</span>
-<span style="color: #b5bd68;">if</span> remaining == <span style="color: #81a2be;">0</span>:
-    <span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'i was last ..'</span>)
-</pre>
-</div>
-
-<p>
-a timeout can be set on the call to wait in second via the &ldquo;<b>timeout</b>&rdquo; argument.If the timeout expires before all parties reach the  barrier, a <b>BrokenBarrierError</b> will be raised
-in all threads waiting on the barrier and the barrier will be marked as broken.
-</p>
-
-<p>
-if a timeout is used via &ldquo;<b>timeout</b>&rdquo; argument  or the default timeout in the constructor, then all calls to the <b>wait()</b> function may need to handle the <b>BrokenBarrierError</b>.
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">wait on the barrier for all other threads to arrive</span>
-<span style="color: #b5bd68;">try</span>:
-    barrier.wait()
-<span style="color: #b5bd68;">except</span> BrokenBarrierError:
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">...</span>
-</pre>
-</div>
-
-<p>
-we can also abort the barrier.aborting the barrier means that all threads waiting on the barrier via the <b>wait()</b> function will raise <b>BrokenBarrierError</b> and the barrier will be put in the broken state.
-</p>
-
-<p>
-to abort the barrier we use <b>abort()</b> function
-</p>
-<div class="org-src-container">
-<pre class="src src-py">barrier.abort()
-</pre>
-</div>
-
-<p>
-a broken barrier cannot be used.Caalls to <b>wait()</b> will raise <b>BrokenBarrierError</b>.
-</p>
-
-<p>
-a barrier can be fixed and made ready for use again by calling the <b>reset()</b> function.
-</p>
-
-<p>
-if you cancel a coodination effort although you wish to retry it again with same barrier instance.
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">reset a broken barrier</span>
-barrier.reset()
-</pre>
-</div>
-
-<p>
-the status of the barrier can be checked via attributes.
-</p>
-
-<ul class="org-ul">
-<li><b>parties</b>: reports the canfigured number of parties that must reach the barrier for it to be lifted.</li>
-<li><b>n<sub>waiting</sub></b>: reports the current number of threads waiting on the barrier.</li>
-<li><b>broken</b>: attribute indicates whether the barrier is currently is currently broken or not.</li>
-</ul>
-</div>
-</div>
-
-<div id="outline-container-org9378a4e" class="outline-3">
-<h3 id="org9378a4e"><span class="section-number-3">21.3.</span> example</h3>
-<div class="outline-text-3" id="text-21-3">
-<p>
-in this example we will create a suite of threads, each required to perform some blocking calculation we will use a barrier to coodinate all threads after they have finished their work and perform some action in the main thread. this is a good proxy for the types of coodination we may need to perform with a barrier.
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python"><span style="color: #b5bd68;">from</span> __init__ <span style="color: #b5bd68;">import</span> *
-<span style="color: #b5bd68;">from</span> random <span style="color: #b5bd68;">import</span> random
-
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">target function to prepare some work</span>
-<span style="color: #b5bd68;">def</span> <span style="color: #de935f;">task</span>(barrier, number):
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">generate a unique value</span>
-    <span style="color: #f0c674;">value</span> = random() * <span style="color: #81a2be;">10</span>
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">block for a moment</span>
-    time.sleep(value)
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">report result</span>
-    <span style="color: #b294bb;">print</span>(f<span style="color: #8abeb7;">'thread </span>{number}<span style="color: #8abeb7;"> done, got: </span>{value}<span style="color: #8abeb7;">'</span>)
-    barrier.wait()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create a barrier</span>
-Tbarrier = threading.Barrier(<span style="color: #81a2be;">5</span>+<span style="color: #81a2be;">1</span>)
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">create the worker threads</span>
-<span style="color: #b5bd68;">for</span> i <span style="color: #b5bd68;">in</span> <span style="color: #b294bb;">range</span>(<span style="color: #81a2be;">5</span>):
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">start a new thread to perform some work</span>
-    <span style="color: #f0c674;">worker</span> = threading.Thread(target=task,args=(Tbarrier,i))
-    worker.start()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">wait for all thread to finish</span>
-<span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'main thread waiting on all results ...'</span>)
-Tbarrier.wait()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">report once all threads are done</span>
-<span style="color: #b294bb;">print</span>(<span style="color: #8abeb7;">'all threads have their result'</span>)
-</pre>
-</div>
-</div>
-</div>
-</div>
-
-<div id="outline-container-org86b3023" class="outline-2">
-<h2 id="org86b3023"><span class="section-number-2">22.</span> pyhton : threading best practices</h2>
-<div class="outline-text-2" id="text-22">
-</div>
-<div id="outline-container-org3b4e83b" class="outline-3">
-<h3 id="org3b4e83b"><span class="section-number-3">22.1.</span> tip 1: use context managers</h3>
-<div class="outline-text-3" id="text-22-1">
-<p>
-acquire and release locks using a context manager, wherever possible.
-</p>
-</div>
-
-<div id="outline-container-org7583928" class="outline-4">
-<h4 id="org7583928"><span class="section-number-4">22.1.1.</span> not use this</h4>
-<div class="outline-text-4" id="text-22-1-1">
-<div class="org-src-container">
-<pre class="src src-python">...
-
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">acquire the lock manually</span>
-lock.acquire()
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">critical section...</span>
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">release the lock</span>
-lock.release()
-</pre>
-</div>
-</div>
-</div>
-
-<div id="outline-container-orgb87f71b" class="outline-4">
-<h4 id="orgb87f71b"><span class="section-number-4">22.1.2.</span> use this for better control over threads (more safe)</h4>
-<div class="outline-text-4" id="text-22-1-2">
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">acquire the lock</span>
-lock.acquire()
-<span style="color: #b5bd68;">try</span>:
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">critical section ...</span>
-<span style="color: #b5bd68;">finally</span>:
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">always release the lock</span>
-    lock.release()
-
-</pre>
-</div>
-
-<p>
-same but less code
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">acquire the lock</span>
-<span style="color: #b5bd68;">with</span> lock:
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">critical section ...</span>
-</pre>
-</div>
-</div>
-</div>
-
-<div id="outline-container-org1637c85" class="outline-4">
-<h4 id="org1637c85"><span class="section-number-4">22.1.3.</span> the real benefit</h4>
-<div class="outline-text-4" id="text-22-1-3">
-<p>
-the benefit of the context manager is that the lock is always released as soon as the block exited,regardless of how it is exited, e.g normally, a return, an error, or an exception.
-</p>
-
-<p>
-this applies to a number of concurency primitives,such as:
-</p>
-
-<ul class="org-ul">
-<li>acquiring ;
-<ul class="org-ul">
-<li>mutex lock via <b>threading.Lock</b> class</li>
-<li>reentrant mutex lock via <b>threading.RLock</b> class</li>
-<li>semaphore via <b>threading.Semaphore</b> class</li>
-<li>condition via <b>threading.Condition</b> class</li>
-</ul></li>
-</ul>
-</div>
-</div>
-</div>
-
-<div id="outline-container-orgc9eb2d5" class="outline-3">
-<h3 id="orgc9eb2d5"><span class="section-number-3">22.2.</span> tip 2 : Use timedouts when waiting</h3>
-<div class="outline-text-3" id="text-22-2">
-<p>
-always use a timedout when waiting on a blocking call.
-</p>
-
-<p>
-many calls made on concurency primitives may block.
-</p>
-
-<p>
-examples:
-</p>
-
-<ul class="org-ul">
-<li>waiting to acquire a <b>threading.Lock()</b> via <b>acquire()</b>.</li>
-<li>waiting for a thread to terminate via <b>join()</b>.</li>
-<li>waiting to be notified on a <b>threading.Condition</b> via <b>wait()</b>.</li>
-<li>and more.</li>
-</ul>
-
-<p>
-All blocking calls on concurrency primitives take a &ldquo;<b>timeout</b>&rdquo; argument and return <b>True</b> if the call was successful or <b>False</b> otherwise.
-</p>
-
-<p>
-Do not call a blocking call without a timedout,wherever possible.
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">acquire the lock</span>
-<span style="color: #b5bd68;">if</span> <span style="color: #b5bd68;">not</span> lock.acquire(timedout=<span style="color: #81a2be;">2</span>*<span style="color: #81a2be;">60</span>):
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">handle failure case ...</span>
-</pre>
-</div>
-
-<p>
-this allow the waiting thread to give-up waiting after a fixed time limit and then attempt to rectify the situation, e.g. report and error, force termination, etc.
-</p>
-</div>
-</div>
-
-<div id="outline-container-orgc1d4a1f" class="outline-3">
-<h3 id="orgc1d4a1f"><span class="section-number-3">22.3.</span> tip 3: use a mutex to protect critical sections</h3>
-<div class="outline-text-3" id="text-22-3">
-<p>
-always use a mutual exclusion (mutex) lock to protect critical sections in code.
-</p>
-
-<p>
-Critical sections are sensitive parts of code that can be executed by multiple threads concurency and may result in race conditions.
-</p>
-
-<p>
-a critical section maay refer to a single block code, but it also refers to multiple accesses oto the same data variable or a resource from multiple functions.
-</p>
-
-<p>
-a mutex lock can be used to ensure that only one thread at a time executes a critical section of code at time, while all other threads trying to execute the same code must wait until the currently executing thread is finished with the critical section and releases the lock.
-</p>
-
-<p>
-each thread must attempt to acquire the lock at the beginning of the critical section.if the lock has not been obtained,then thread will acquire it and other threads must wait until the thread that acquired the lock releases it.
-</p>
-
-<div class="org-src-container">
-<pre class="src src-python">...
-<span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">acquire the lock</span>
-<span style="color: #b5bd68;">with</span> lock:
-    <span style="color: #969896; font-style: italic;"># </span><span style="color: #969896; font-style: italic;">critical section ...</span>
-</pre>
-</div>
-</div>
-</div>
-
-
-<div id="outline-container-org7a0eecf" class="outline-3">
-<h3 id="org7a0eecf"><span class="section-number-3">22.4.</span> tip 4: acquire locks in order</h3>
-<div class="outline-text-3" id="text-22-4">
-<p>
-acquire locks in the same order throught the application, wherever possible.
-</p>
-
-<p>
-this is called &ldquo;lock ordering&rdquo;.
-</p>
-
-<p>
-in some applications you may be able to abstract the acquisition of lock using a list of <b>threading.Lock</b> object that may be itered  and acquired in order, or a function call that acquired locks in sonsistent order.
-</p>
-
-<p>
-when this is not possible, you may need to audit your code to confirm that all paths throught the code acquire the locks in same order.
-</p>
-</div>
-</div>
-</div>
-
-<div id="outline-container-org67bc6ac" class="outline-2">
-<h2 id="org67bc6ac"><span class="section-number-2">23.</span> python : threading common errors</h2>
-<div class="outline-text-2" id="text-23">
-</div>
-<div id="outline-container-orgca91685" class="outline-3">
-<h3 id="orgca91685"><span class="section-number-3">23.1.</span> race conditions</h3>
-</div>
-<div id="outline-container-orge5722db" class="outline-3">
-<h3 id="orge5722db"><span class="section-number-3">23.2.</span> thread deadlocks</h3>
-</div>
-<div id="outline-container-orgdd4862a" class="outline-3">
-<h3 id="orgdd4862a"><span class="section-number-3">23.3.</span> thread livelocks</h3>
-</div>
-</div>
-<div id="outline-container-org1ec93b4" class="outline-2">
-<h2 id="org1ec93b4"><span class="section-number-2">24.</span> python threading common questions</h2>
-<div class="outline-text-2" id="text-24">
-<p>
-<b>*
-*</b>
-<b>*
-*</b>
-<b>*
-*</b>
-<b>*
-*</b>
-<b>*
-*</b>
-**
-</p>
-</div>
-</div>
-<div id="outline-container-org9727e75" class="outline-2">
-<h2 id="org9727e75"><span class="section-number-2">25.</span> resources</h2>
-<div class="outline-text-2" id="text-25">
-<ul class="org-ul">
-<li><a href="https://superfastpython.com/threading-in-python/#Python_Threads">https://superfastpython.com/threading-in-python/#Python_Threads</a></li>
-</ul>
-</div>
-</div>
-</div>
-<div id="postamble" class="status">
-<p class="author">Author: mal1kc</p>
-<p class="date">Created: 2023-03-12 Sun 12:54</p>
-</div>
-</body>
-</html>
\ No newline at end of file
diff --git a/python/threading_parallel_processing/readme.md b/python/threading_parallel_processing/readme.md
deleted file mode 100644
index 2bb762f..0000000
--- a/python/threading_parallel_processing/readme.md
+++ /dev/null
@@ -1,1686 +0,0 @@
-
-# Table of Contents
-
-1.  [what are threads](#orgdeea90c)
-2.  [thread vs process](#orgf4a3e5e)
-3.  [life-cycle of thread](#org6fb7fc8)
-4.  [run a func in thread](#orgbfa1034)
-    1.  [how to run a func in thread](#org271052c)
-        1.  [example](#org27a8085)
-        2.  [example with arguments](#org283a2e3)
-5.  [extend the thread class](#orgfddeb77)
-    1.  [possible usage cases](#org9d90c31)
-    2.  [example of extending the thread class](#org3fa548d)
-    3.  [example of extending the thread class with return values](#org2dcb55d)
-6.  [thread instance attributes](#org6eb26e2)
-    1.  [thread name](#org79acdfe)
-    2.  [thread daemon](#orga7eb327)
-    3.  [thread identifier](#orgf19ee20)
-    4.  [thread native identifier](#org8747b32)
-    5.  [thread alive status](#orge648fc5)
-        1.  [in example:](#orgde66bfb)
-7.  [configure threads](#org351ba06)
-    1.  [how to configure thread name](#orgce3c545)
-    2.  [how to configure thread daemon](#org4d40ebd)
-        1.  [for example:](#org0792791)
-8.  [whats main thread](#org13c455a)
-9.  [Thread Utilities](#orgf6cab4a)
-    1.  [number of active threads](#org79530ae)
-    2.  [current thread](#orgc083834)
-    3.  [thread identifier](#org141db44)
-    4.  [native thread identifier](#orgd426d59)
-    5.  [enumarate active threads](#org02a2d8d)
-10. [thread exception handling](#org7dbbf9a)
-    1.  [unhandled exception](#org50c3d07)
-    2.  [exception hook](#orga79191a)
-        1.  [example](#orgc41b0e6)
-11. [limitation of threads in cpython](#org1ceeb6f)
-12. [when to use thread](#org90a387c)
-    1.  [use threads for blocking IO](#orge06dac7)
-    2.  [use threads external c code (that realses the GIL)](#orga8e8357)
-    3.  [use threads with (some) third-party python interpreter](#org7acae53)
-13. [threads blocking calls](#orgefab684)
-    1.  [blocking calls on concurrency primitives](#orgbb9ab0b)
-    2.  [blocking calls for I/O](#orgcc2e25b)
-    3.  [blocking calls to sleep](#org73af413)
-14. [thread-local data](#orgb327cf4)
-    1.  [example](#orgcea4521)
-15. [thread mutex lock - *threading.Lock*](#org4c0eb35)
-    1.  [what is mutual exclusion lock](#org87f7ee5)
-        1.  [why we need mutual exclusion lock](#org8a0d268)
-        2.  [description of mutex](#orgb3ec348)
-    2.  [how to use mutex lock](#org70813e5)
-        1.  [for example](#org7d5d6a7)
-    3.  [example of using mutex lock](#org33f28e0)
-16. [thread reentrant lock  - *threading.RLock*](#org9e338b8)
-    1.  [what is reentrant lock](#org294fa8d)
-        1.  [why we neet reentrant lock](#org7e57369)
-        2.  [description of reentrant lock](#org094200f)
-    2.  [how to use reentrant lock](#org1082607)
-    3.  [example of using reentrant lock](#orge3992d5)
-17. [thread condition - *threading.Condition*](#orga0b2eeb)
-    1.  [what is a threading condition](#orga1e762e)
-    2.  [how to use condition object](#org97e340a)
-    3.  [example of wait and notify with a condition](#orgbb1f38f)
-18. [thread semaphore - *threading.Semaphore*](#org1e3065c)
-    1.  [what is a semaphore](#org22f0f95)
-    2.  [how to use a semaphore](#orga546941)
-        1.  [acquiring and releasing](#org7e38ed5)
-    3.  [example](#org6b73561)
-19. [thread event - *threading.Event*](#org28fa160)
-    1.  [how to use event object](#org6710876)
-    2.  [example](#orge51419a)
-20. [timer threads - *threading.Timer*](#org4f829c0)
-    1.  [how to use a timer thread](#orgbca5f69)
-    2.  [example of using a timer thread](#orgfd5839b)
-21. [thread barrier - *threading.Barrier*](#orgfc2194a)
-    1.  [what is barrier](#orgd25f2ce)
-    2.  [how to use barrier](#org0da4560)
-    3.  [example](#org96a6a28)
-22. [pyhton : threading best practices](#org84d897e)
-    1.  [tip 1: use context managers](#org228524f)
-        1.  [not use this](#org7b02d5e)
-        2.  [use this for better control over threads (more safe)](#org974ed0a)
-        3.  [the real benefit](#org9d6d17b)
-    2.  [tip 2 : Use timedouts when waiting](#orgb7cc37b)
-    3.  [tip 3: use a mutex to protect critical sections](#org36c2ce4)
-    4.  [tip 4: acquire locks in order](#orge26d1f7)
-23. [python : threading common errors](#org6784994)
-    1.  [race conditions](#orgca7c287)
-    2.  [thread deadlocks](#org9804145)
-    3.  [thread livelocks](#org75500b0)
-24. [python threading common questions](#org47c70b9)
-25. [resources](#org1fb73c4)
-
-
-
-<a id="orgdeea90c"></a>
-
-# what are threads
-
-threads refers to thread of execution in computer program
-
-> Thread: The operating system object that executess the instructions of a process
-> 
-> -   book: page 273,the art of concurency,2009.
-
-when we run python script, it starts an instance of python interpreter that runs our code in the main thread.
-the main threads is the default thread of a python process
-
-we may develop our program to  perform tasks concurently in that case we may need threads,these are concurent threads of execution without our program
-example of this will be:
-
--   execution funtion calls concurently
--   execution object methods concurently
-
-a python thread is an object representation of native thread provided by operating system
-
-when we create and run a new thread, Python will make system calls on the underlaying op. system and request new thread be created and start running new thread
-
-the code in new threads may or may not be executed in parallel,even though the threads are executed concurently.
-
-these are number of reasons for this,such as:
-
--   the underlaying hardware may or may not support parallel execution (e.g. one vs multiple CPU cores)
--   the python interpreter may or may not permity multiple threads execute in parallel
-
-> this highlights the distiction between concurent and parallel execution
-
--   **Concurrent** : Code that can be executed out of order
--   **Parallel** : Capability to execute code simultaneously
-
-
-<a id="orgf4a3e5e"></a>
-
-# thread vs process
-
-a process refers to a computer process
-
-> process: the operating system&rsquo;s spawned and controlled entity that encapsulates an executing application.
-> a process has two main functions. the first is to act as the resource holder for the application,
-> and the second is to execute the instructions of the application.
-> 
-> -   book: page 271,the art of concurency,2009
-
-the op system controls how new processes are created on some system,that may require spawning a new process,and on others,it may require that process is forked.
-in Cpython implementation we not need to worry because python interpreter is manage
-creating new processes.
-
-a thread always exists within a process and represents the manner in which instructions or code is executed.
-
-a process will have at least one thread, called the main thread.Any additional
-threads that we create within the process will belong to that process.
-
-the python process will terminate once all(non background threads) are terminated
-
--   **process**: an instance of the python interpreter has atleast one thread called MainThread
--   **thread**: a thread of execution within Python process,such as the MainThread or new thread.
-
-
-<a id="org6fb7fc8"></a>
-
-# life-cycle of thread
-
-a thread in python is object instanced from  **threading.Thread** class
-
-once a thead is started, interpreter will interface with the operating system and request that new native thread be created. the instance of **threading.Thread**
-the provides a python-based reference to his underlaying native thread.
-
-each thread follows same life-cycle . understanding of its life-cycle help with
-concurent programming in python.
-
-for example:
-
--   the diffrence between creatimg and starting a thread
-
--   the diffrence between run and start
-
--   the diffrence between blocked and terminated
-
-while running, the thread may be executing code or may be blocked,waiting on something such as another thread or external resource.although, not all threads may block, it is optinal base on specific use case for the new thread.
-
-1.  new thread
-2.  running thread
-    1.  blocked thread (optinal).
-3.  terminated thread.
-
-A new thread is a thread that has been constructed by. creating an instance of the **threading.Thread** class
-
-a new thread can transition to a running thread by calling the start() function.
-
-a running thread may block in many ways, such as reading or writing from a file or a socket or by waiting on concurency primitive such as semaphore or a lock
-after blocking,the thread will run again.
-
-finaly, a thread may terminate once it has finished executing its code or by raising
-error or exception
-
-[thread life cycle diaram](./thread-life-cycle.webp)
-
-
-<a id="orgbfa1034"></a>
-
-# run a func in thread
-
-python funcs can executed in a seperatie thread using **threading.Thread** class
-
-
-<a id="org271052c"></a>
-
-## how to run a func in thread
-
-the func executed in another thread may have args in which case can be specificed as aa tuple and passed to the &ldquo;**args**&rdquo; argument of the threading.threading class constructor or as dictionart to the &ldquo;**kwargs**&rdquo; argument.
-
-the **start()** func will return immediately and the operating system will execute    the function in a seperate thread as soon as it is able.
-
-we do not have control over when the thread will execute precisely or which cpu core wwill execute it. both of these are low-level responsibilities that are handled by operating system.
-
-> doing nessesary imports for examples
-
-    
-    # doing nessesary imports for examples
-    import threading
-    import time
-
-
-<a id="org27a8085"></a>
-
-### example
-
-    from __init__ import *
-    
-    def task():
-        # block for 1 second
-        time.sleep(1)
-        # display a message
-    
-        print('this is from another thread')
-    
-    thread = threading.Thread(target=task)
-    thread.start()
-    print('waiting fo the thread ..')
-    thread.join() # explicitly waiting to finish thread
-
-running the example first creates instance  of threeding.Thread then calls the **start()** func.This does not start the thread immediately,but instead allows to operating system to schedule the function to execute as soon as possible.
-
-the main thread then prints a message &rsquo;*waiting &#x2026;*&rsquo; ,then calls the **join()** function to explicitly block and wait for the new thread to finish executing.
-
-
-<a id="org283a2e3"></a>
-
-### example with arguments
-
-    from __init__ import *
-    
-    def task(sleep_time,message):
-        # block for 1 second
-        time.sleep(sleep_time)
-        # display a message
-        print(message)
-    
-    
-    thread = threading.Thread(target=task,args=(1.5,'new message from another thread'))
-    thread.start()
-    print('waiting fo the thread ..')
-    thread.join() # explicitly waiting to finish thread
-
-
-<a id="orgfddeb77"></a>
-
-# extend the thread class
-
-we can also execute funcs in another thread by extending the **threading.Thread** class and overriding the run() function.
-
-In this section we will look at some examples of extending **thread.Thread** class
-
-
-<a id="org9d90c31"></a>
-
-## possible usage cases
-
-given that it is a custom class,you can defina a constructor for the class and use it to pass in data that may be needed in the **run()** function, stored as instance variables (attributes).
-
-you can also define additional functions on the class to split up the work you may need to complete another thread.
-
-finally, attributes caan also be used to store the results of any calculation or IO performed in another thread that may be need to be retrieved afterward.
-
-
-<a id="org3fa548d"></a>
-
-## example of extending the thread class
-
-example code :
-
-    class CustomThread(Thread):
-        ...
-
-this will inherit **Thread** class to our **CustomThread** class,then we need override
-**run()** func to execute another threads funcs,overriding a function very basic as syntax:
-
-    def run(self):
-        sleep(1)
-        print('this is coming from another thread')
-    
-    # create the thread
-    thread = CustomThread()
-    
-    # start the thread
-    
-    thread.start()
-    
-    # wait for the thread finish
-    
-    print('waiting for the thread to finish')
-    
-    thread.join()
-
-complete code would be like:
-
-    from __init__ import *
-    
-    class CustomThread(threading.Thread):
-        def run(self):
-            time.sleep(1)
-            print('this is coming from another thread')
-    
-    
-    thread = CustomThread()
-    thread.start()
-    print('waitin for thread finish')
-    thread.join()
-
-
-<a id="org2dcb55d"></a>
-
-## example of extending the thread class with return values
-
-    from __init__ import *
-    
-    class CustomThread(threading.Thread):
-        def run(self):
-            time.sleep(1)
-            print('this is coming from another thread')
-            self.value = 99
-    
-    thread = CustomThread()
-    thread.start()
-    print('waitin for thread finish')
-    thread.join()
-    value = thread.value
-    print(f'{value=}')
-
-
-<a id="org6eb26e2"></a>
-
-# thread instance attributes
-
-an instance of the thread class provides a handle of a thread of execution.
-it provides attributes that we can use to query properties and the status of the underlaying thread.
-
-
-<a id="org79acdfe"></a>
-
-## thread name
-
-threads are named automatically in a somewhat unique manner within each process withe the form &ldquo;Thread-%d&rdquo; where %d is the integer indicating the thread number within the process,e.g. Thread-1 for the first thread created.
-
-
-<a id="orga7eb327"></a>
-
-## thread daemon
-
-a thread may be a deamon thread, daemon threads is the name givent to background threads.by default threads are non-daemon threads.
-
-a python program will only exit when all non-daemon threads have finished exiting. for example , the main threads is a non-daemon threads.this means that daemon threads can run in the background and do not have to finish or be explicitly excited for the program end.
-
-
-<a id="orgf19ee20"></a>
-
-## thread identifier
-
-each thread has unique identifier (id) within python process,assigned by python interpreter.
-
-the identifier is a read-only positive integer value and is assigned only after thread has been started.
-
-can be accesed via **&ldquo;ident&rdquo;** property
-
-
-<a id="org8747b32"></a>
-
-## thread native identifier
-
-each thread has unique identifier assigned by the operating system.
-
-python threads (cpython) are real native threads,means that each thread we created is actually created and managed (scheduled) by operating system.As such, the operating system will assing a unique integer to each thread that is created on the system (across processes).
-
-can be acced via **&ldquo;native<sub>id</sub>&rdquo;** property
-
-it is assigned after thread has been started
-
-
-<a id="orge648fc5"></a>
-
-## thread alive status
-
-thread class property that holds is thread running or dead (non-started or finished)
-
-
-<a id="orgde66bfb"></a>
-
-### in example:
-
-    from __init__ import *
-    
-    # create instance of Thread object with lambda func
-    thread = threading.Thread(target=lambda:(
-    time.sleep(0.2),
-    print('this is from another thread')
-    ))
-    # report thread alive status
-    is_alive = thread.is_alive()
-    print(f'thread\'s {is_alive=}')
-    # report thread identifier value
-    ident = thread.ident
-    print(f'{ident=}')
-    # report thread daemon property
-    daemon = thread.daemon
-    print(f'{daemon=}')
-    name = thread.name
-    print(f'{name=}')
-    thread.start()
-    # report thread native id property
-    native_id = thread.native_id
-    print(f'{native_id=}')
-    is_alive = thread.is_alive()
-    print(f'{is_alive=}')
-    ident = thread.ident
-    print(f'{ident=}')
-    thread.join()
-    is_alive = thread.is_alive()
-    print(f'{is_alive=}')
-
-
-<a id="org351ba06"></a>
-
-# configure threads
-
-
-<a id="orgce3c545"></a>
-
-## how to configure thread name
-
-the name of a thread can be ser via the **&ldquo;name&rdquo;** argument in the threading.Thread constructor
-
-
-<a id="org4d40ebd"></a>
-
-## how to configure thread daemon
-
-a thread may be configured to be a daemon or not,and most threads in concurrent programming,including the main thread,are non-daemon threads(no background threads) by default
-
-can be configured via setting **&ldquo;daemon&rdquo;** argument to True in the constructor
-
-
-<a id="org0792791"></a>
-
-### for example:
-
-    from __init__ import *
-    thread = threading.Thread(name='daemon Thread',daemon=True,target=lambda:print(f'this message is from daemon thread'))
-    print(f'{thread.daemon=}')
-    print(f'{thread.name=}')
-    thread.start()
-
-
-<a id="org13c455a"></a>
-
-# whats main thread
-
-each python process is created with one default thread called the **&ldquo;the main thread&rdquo;**
-
-when we execute a python program, it is executing in the main thread.
-
-the main thread is created for each python process
-
-> in normal conditions, the main thread is thread from which the python interpreter was started.
-
-&#x2013; [threading &#x2013; Thread-based parallelism](https://docs.python.org/3/library/threading.html)
-
-the main thread in each python process always has the name **&ldquo;MainThread&rdquo;** and is not a daemon thread.Once the **&ldquo;main thread&rdquo;** exists,the Python will exit,assuming there are non-daemon threads running.
-
-> there is a &ldquo;main thread&rdquo; object;this corresponds to initial thread of control in python program.It is not a daemon thread.
-
-&#x2013; [threading &#x2013; Thread-based parallelism](https://docs.python.org/3/library/threading.html)
-
-we can acquire a main thread by calling **threadin.current<sub>thread</sub>()**
-
-    from __init__ import *
-    
-    from threading import current_thread
-    thread = current_thread()
-    print(f'thread;\n{thread.name=},{thread.daemon=},{thread.ident=}')
-
-
-<a id="orgf6cab4a"></a>
-
-# Thread Utilities
-
-
-<a id="org79530ae"></a>
-
-## number of active threads
-
-**threading.active<sub>count</sub>()** gives integer that indicates number of threads that are &ldquo;alive&rdquo;
-
-
-<a id="orgc083834"></a>
-
-## current thread
-
-**threading.current<sub>thread</sub>()** gives **threading.Thread** instance of thread running the current code
-
-
-<a id="org141db44"></a>
-
-## thread identifier
-
-**threading.get<sub>ident</sub>()** gives current threads identifier integer
-
-
-<a id="orgd426d59"></a>
-
-## native thread identifier
-
-**threading.get<sub>ident</sub>()** gives current threads identifier integer that assigned by operating system
-
-
-<a id="org02a2d8d"></a>
-
-## enumarate active threads
-
-we can get a list of active threads via calling **threading.enumarate()** function,it returns list of active threads
-
-    
-    from __init__ import *
-    active_thread_count = threading.active_count()
-    print(f'{active_thread_count=}')
-    current_thread = threading.current_thread()
-    current_thread.name="main thread"
-    print(f'{current_thread=}')
-    print(f'{threading.get_ident()=}')
-    thread = threading.Thread(name='other thread',target=lambda:print(f'this message is from daemon thread'))
-    print(f'{threading.get_native_id()=}')
-    thread.start()
-    threads = threading.enumerate()
-    for th in threads:
-        print(f'{th.name=}')
-    thread.join()
-
-
-<a id="org7dbbf9a"></a>
-
-# thread exception handling
-
-
-<a id="org50c3d07"></a>
-
-## unhandled exception
-
-an unhandled exception can occur in a new thread.
-
-the effect will be that the thread will unwind and report the message on standart
-error.Unwinding the thread means that the thread will stop executing at the point of the (or error) and that the exception will bubble up the stack in the thread until it reaches the top level,e.g. the run() funtion.
-
-    from __init__ import *
-    
-    def work():
-        print('working .',end='')
-        for ti in range(10):
-            time.sleep(0.5)
-            print('. .',end='')
-        print('..')
-        raise Exception('something bad happened')
-    thread = threading.Thread(target=work)
-    thread.start()
-    thread.join()
-    print('continuing on ...')
-    time.sleep(0.2)
-    print('finished')
-
-
-<a id="orga79191a"></a>
-
-## exception hook
-
-we can specify how to handle unhandled errors aand exceptions that occuur within new threads via the exception hook
-
-by default,there is no exception hook, in which case the **[sys.excepthook function](https://docs.python.org/3/library/sys.html#sys.excepthook)**
-is called that reports the familiar message.
-
-first, we must define a function that takes a single argument that will be an instance of the **ExceptHookArgs** class,containing details of the exception and thread
-
-
-<a id="orgc41b0e6"></a>
-
-### example
-
-    
-    from __init__ import *
-    
-    def work():
-        print('working .',end='')
-        for ti in range(10):
-            time.sleep(0.5)
-            print('. .',end='')
-        print('..')
-        raise Exception('something bad happened')
-    def custom_hook(args):
-        print(f'thread failed:{args.exc_value}')
-    threading.excepthook = custom_hook
-    thread = threading.Thread(target=work)
-    thread.start()
-    thread.join()
-    print('continuing on ...')
-    time.sleep(0.2)
-    print('finished')
-
-
-<a id="org1ceeb6f"></a>
-
-# limitation of threads in cpython
-
-python interpreter generally does not permit more than one thread to run at a time
-
-this is achieved via mutal exclusion (mutex) lock within interpreter that ensures that only one thread at a time can execute python bytecodes in python virtual machine .
-
-> In CPython, due to the Global Interpreter Lock, only one thread can execute Python code at once (even though certain performance-oriented libraries might overcome this limitation).
-
-&#x2013; [threading &#x2013; Thread-based parallelism](https://docs.python.org/3/library/threading.html)
-
-this lock is referred to as the **Global interpreter Lock** or **GIL** for short.
-
-> In CPython, the global interpreter lock, or GIL, is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecodes at once. The GIL prevents race conditions and ensures thread safety.
-
-&#x2013; [GLOBAL INTERPRETER LOCK, PYTHON WIKI](https://wiki.python.org/moin/GlobalInterpreterLock)
-
-this means that although we might write concurent code  with threads and run our code  on hardware with many CPU cores, we may not be able to execute our code in parallel
-
-there are some exceptions to this.
-
-specially, the **GIL** is released by the Python interpreter sometimes to allow other threads to run.
-
-such as when the thread is blocked ,such as performing IO with socket or file, or often if the thread is executing computationally intesive code in C library,like hashing bytes.
-
-> Luckily, many potentially blocking or long-running operations, such as I/O, image processing, and NumPy number crunching, happen outside the GIL. Therefore it is only in multithreaded programs that spend a lot of time inside the GIL, interpreting CPython bytecode, that the GIL becomes a bottleneck.
-
-&#x2013; [GLOBAL INTERPRETER LOCK, PYTHON WIKI](https://wiki.python.org/moin/GlobalInterpreterLock)
-
-therefore, although in most cases Cpython will prevent parallel execution of threads, it is allowed in some circumstances,these  circumstances represent the base use case for adopting threads in our python programs.
-
-
-<a id="org90a387c"></a>
-
-# when to use thread
-
-there are times when the GIL lock is released by the interpreter and we can achieve  parallel execution of our concurent code in python.
-
-**examples of when lock is released include:**
-
--   when thread is performing blocking IO
-
--   when a thread is executing C code  and explicitly releases
-
-**there are also ways of avoiding the lock entirely,such a:**
-
--   using third-party interpreter to execute python code
-
-
-<a id="orge06dac7"></a>
-
-## use threads for blocking IO
-
-should use threads for IO bound tasks.
-
-an IO-bound task is a type of tash that involves reading from or writing to device, file, or socket connection.
-
-modern CPUs, like a 4GHz CPU, can execute 4 billion instructions per second, and you likely have more than one CPU core in your system.
-
-doing IO is very slow compared to the speed of CPUs.
-
-interacting with devices,reading  and writing files and socket connections involves calling instructions in your operating system ,which will wait for the operation to complete. If this operation is the main focus for your Cpu ,such as executing in the main thread of your python program,then your cpu is going to wait many milliseconds or even many seconds doing nothing.
-
-that is probably preventing billions of operations from executing.
-
-a thread performing an IO operation will block for the duration of the operation.While blocked,this signals to the operating system that a thread can be suspended and onether thread can execute, called a context switch.
-
-additonally, python interpreter will release the GIL when performing blocking IO operations,allowing other threads within the python process to execute.
-
-therefore, blocking IO provides an excellent use case for using threads in python.
-
-examples of blocking IO operations include:
-
--   reading or writing a file from the hard drive.
-
--   reading or writing to standart output, input or error(stdin,stdout,stderr).
-
--   printing a document.
-
--   reading or writing bytes on a socket connection with a server.
-
--   downloading or uplading a file.
-
--   query a server.
-
--   query a database.
-
--   taking a photo.
-
--   everythin that includes disk write read
-
-
-<a id="orga8e8357"></a>
-
-## use threads external c code (that realses the GIL)
-
-we may make function calls that themselves call down into a third-party C library.
-
-Often these function calls will realase the GIL as the C library being called will not interact with the intpreter.
-
-this provides an opputunity for other threads in the python process to run.
-
-**for example**,when using the &ldquo;**hash**&rdquo; module in python std library,the GIL is released when hashing the data via the [hash.update() function](https://docs.python.org/3/library/hashlib.html#hashlib.hash.update)
-
-> The Python GIL is released to allow other threads to run while hash updates on data larger than 2047 bytes is taking place when using hash algorithms supplied by OpenSSL.
-
-&#x2013; [HASHLIB — SECURE HASHES AND MESSAGE DIGESTS](https://docs.python.org/3/library/hashlib.html)
-
-Another example is the NumPy library for managing arrays of data which will release the GIL when performing functions on arrays.
-
-> The exceptions are few but important: while a thread is waiting for IO (for you to type something, say, or for something to come in the network) python releases the GIL so other threads can run. And, more importantly for us, while numpy is doing an array operation, python also releases the GIL.
-
-&#x2013; [WRITE MULTITHREADED OR MULTIPROCESS CODE, SCIPY COOKBOOK](https://scipy-cookbook.readthedocs.io/items/ParallelProgramming.html)
-
-
-<a id="org7acae53"></a>
-
-## use threads with (some) third-party python interpreter
-
-there are alternate commericial and open source python interpreters that you can acquire and use to execute your python code.
-
-some python interpreters may implement a GIL and release it more or less than Cpython. Other interpreters remove the GIL entirely and allow multiple python concurent threads to execute in parallel.
-
-
-<a id="orgefab684"></a>
-
-# threads blocking calls
-
-a blocking call is a function call that does not return until is complete.
-
-all normal functions are blocking calls.
-
-blocking call are calls to functions that will wait for a specific condition and signal to the operating system that nothing interesting going on while the thread is waiting.
-
-the os may notice that a thread is making a blocking function call and decide to context switch to another thread.
-
-you may recall that the os manages what threads should run and when to run them.it achieves this using a type of multitasking where a running thread is suspended and suspended thread is restored and continues running.This suspending and restoring of threads is called a context switch.
-
-the os prefers to context switch away from blocked threads, allowing non-blocked threads to run.
-
-this means if a thread makes a blocking function call,a call that waits, then it is likely to signal that the thread can be suspended and allow other threads to run.
-
-similarly, many function calls that we may traditionally think block may have non-blocking versions in modern non-blocking concurrency APIs, like asyncio.
-
-there are three types of blocking function calls you need to consider in concurrent programming, they are:
-
--   blocking calls on concurent primitives
-
--   blocking calls for IO
-
--   blocking calls to sleep
-
-
-<a id="orgbb9ab0b"></a>
-
-## blocking calls on concurrency primitives
-
-there are many blocking calls in concurrent programming
-
-common ways are;
-
--   waiting for a lock,e.g. calling acquire() from &rsquo;threading.Lock&rsquo; class
--   waiting to be notified,e.g. calling wait() from &rsquo;threading.Condition&rsquo; class
--   waiting for a thread to terminate ,e.g. calling join() from &rsquo;threading.Thread&rsquo; class
--   waiting for an event,e.g. calling wait() from &rsquo;threading.Event&rsquo; class
--   waiting for a barrier,e.g. calling wait() from &rsquo;threading.Barrier&rsquo; class
-
-
-<a id="orgcc2e25b"></a>
-
-## blocking calls for I/O
-
-conventionally,function calls that interact with I/O are mostly blocking calls.they are blocking in same sencse as blocking calls in concurency primitives
-the wait for the I/O device respond is another signal to operating system that the thread can be context switched.
-
-common examples are;
-
--   **hdd(hard disk drive)** :reading,writing,appending,renaming,deleting,.. files
--   **perpheral devices**    :mouse,keyboard,screen,printe,camera,serial device etc.
--   **database**             :sql queries
--   **internet**             :downloading,uplading,http requests,etc.
-    -   **email**                :send,receieve,querry inbox,etc.
--   **and more,mostly other socket related things**
-
-performing I/O operations with devices is typically very slow compared to CPU operations.
-
-the I/O with devices is coordinated by the operating system and the device.this means the operating system can gather or sen some bytes from or to device.this means operating system can gather or send some bytes from or to the device then context switch back to the blocking thread when needed allowing the function call to progress.
-
-
-<a id="org73af413"></a>
-
-## blocking calls to sleep
-
-the sleep() function is a capability provided by the underlying operating system that we can make use of within our program.
-
-it is a blocking function call that pauses the thread to block for a fixed time in seconds.
-in cpython this can be achieved via **&rsquo;sleep(seconds)&rsquo;** function call from built-in **time** module
-
-    
-    # sleep for 5 seconds
-    import time
-    ...
-    time.sleep(5)
-    ...
-
-it is a blocking call it signals to the operating system that the thread is waiting and is a good candidate for a context switch.
-
-sleeps are often ısed when timing is important in an application.
-
-in programming, adding a sleep can be useful way to simulate waiting within fixed interval.
-
-sleep often used in worked examples when demonstrating concurrency programming,but adding sleeps to code can also aid in unit testing and debugging concurency failure conditions,such as race conditions by forcing mistiming of events within a dynamic application
-
-
-<a id="orgb327cf4"></a>
-
-# thread-local data
-
-threads can store local data via an instance of the **threading.local** class
-
-example
-
-    import threading
-    # create a instance of local class
-    
-    local = threading.local()
-    
-    # store some data
-    local.custom = 33
-
-importantly,other threads can use the same property names on local but the values will be limited to each thread.
-this is like a namespace limited to each thread and is called &ldquo;thread-local data&rdquo;.it means that threads cannot acces or read the local data of other threads.
-importantly, each thread must hang on to the &ldquo;local&rdquo; instance in order to acces the stored data.
-
-
-<a id="orgcea4521"></a>
-
-## example
-
-    
-    from __init__ import *
-    
-    def task(value:int):
-        # create local storage
-        local=threading.local()
-        # store value in local storage
-        local.value = value
-        # block for given time
-        time.sleep(value)
-        # retrieve given value
-        print(f'stored value: {local.value}')
-    
-    # create thread and start thread
-    threading.Thread(target=task,args=(1,)).start()
-    # create another thread and start it
-    threading.Thread(target=task,args=(2,)).start()
-
-
-<a id="org4c0eb35"></a>
-
-# thread mutex lock - *threading.Lock*
-
-
-<a id="org87f7ee5"></a>
-
-## what is mutual exclusion lock
-
-
-<a id="org8a0d268"></a>
-
-### why we need mutual exclusion lock
-
-<div class="org-center">
-<p>
-a <span class="underline">mutual exclusion lock</span> is a synchronization primitive intented to prevent a race condition.
-</p>
-
-<p>
-a race conditions is a concurency failure case when two threads run same code and access or update same resource leaving the resource unkown and inconsistent state.
-these censitive parts of cade that can be executed by multiple threads concurently and may result in race conditions are called critical sections, a critical
-section may refer to single block of code, but is also refers to multiple accesses to the same data variable or resource from multiple functions.
-</p>
-</div>
-
-
-<a id="orgb3ec348"></a>
-
-### description of mutex
-
-<div class="org-center">
-<p>
-mutual exclusion lock also known as mutex,is synchronization mechanism used to control acces to a shared resource in concurent system.A mutex is essentially a binary semaphore (e.g railroad switch signals) with two states;locked and unlocked.When a thread acquires a mutex,it sets the lock to locked state,preventing other threads from also acquiring the lock.The thread that acquire the lock is said to have exclusive acces to the shared resource.When the thread releases the lock.The thread that acquired the lock is said to gave exclusive access to the shared resource.When the thread releases the lock,it sets the lock to the unlocked state, allowing other thread to acquire the lock and gain access to the shared resource.this mechanism ensures that only one thread can access resource at a time, preventing race conditions and other synchronization issues.
-</p>
-</div>
-
-
-<a id="org70813e5"></a>
-
-## how to use mutex lock
-
-<div class="org-center">
-<p>
-the class implementing primitive lock objects.
-</p>
-
-<p>
-NOTE : that <span class="underline">Lock</span> is actually a factory function which returns an instance of the most efficient version of the concrete Lock class that is supported by the platform
-</p>
-</div>
-
-    # create a lock
-    lock = threading.Lock()
-    # acquire the lock
-    # ...
-    # release the lock
-    lock.release()
-
-only one thread can acquire lock,if lock not released it cannot be acquired again.
-
-the thread attempting to acquire the lock will block until the lock is acquired, such as if another thread currently holds the lock then releases it.
-
-we can attempt to acquire the lock without blocking by setting the &ldquo;blocking&rdquo; arg to **False**. if the lock cannot be acquired,a value of **False** is returned.
-
-    ...
-    # acquire the lock without blocking
-    lock.acquire(blocking=false)
-
-we can also attempt to acquire the lock with a timeout,If the lock cannot be acquired a **False** returned.
-
-    ...
-    # acquire the lock with a timeout
-    lock.acquire(timeout=10)
-
-
-<a id="org7d5d6a7"></a>
-
-### for example
-
-    ...
-    # create a lock
-    lock = threading.Lock()
-    # acquire the lock
-    with lock:
-        # ...
-
-this is preffered usage as it makes it clear where the protected code starts and ends,and ensures that the lock is always released, even if there is an exception or error within the critical section.
-
-also we can check if the lock is currently acquired by a thread
-
-    if lock.locked():
-        # if lock is acquired runs this indent block of code
-    else:
-        # if not lock is acquired runs this indent block of code
-
-
-<a id="org33f28e0"></a>
-
-## example of using mutex lock
-
-    
-    from __init__ import *
-    from random import random
-    
-    def task(lock,identifier,value:int|float):
-        # acquire the lock
-        with lock:
-            print(f'>thread {identifier} got the lock,sleepin for {value}')
-            time.sleep(value)
-    # create shared lock
-    lock = threading.Lock()
-    for i in range(10):
-        threading.Thread(target=task, args=(lock, i, random())).start()
-
-
-<a id="org9e338b8"></a>
-
-# thread reentrant lock  - *threading.RLock*
-
-
-<a id="org294fa8d"></a>
-
-## what is reentrant lock
-
-a reentrant mutual exclusion lock aka &ldquo;reenrant mutex&rdquo; or &ldquo;reentrant lock&rdquo; for short, is like a mutex lock except it allows a thread to acquire the lock more than once.
-
-> a reentrant lock is synchranization primitive that may be acquired multiple times by the same thread [&#x2026;] In the locked state,some thread owns the lock;in the unlocked state no thread owns it
-
-&#x2013; [rlock objects &#x2013; Thread-based parallelism](https://docs.python.org/3/library/threading.html#rlock-objects.html)
-
-
-<a id="org7e57369"></a>
-
-### why we neet reentrant lock
-
-we can imagine critical sections spread across a number of funcstions,each protected by the same lock.A thread may call across these functions in course of normal execution and may call into one critical section from another critical section.
-
-a limitation of a (non-reentrant) mutex lock is that if a thread has acquired the lock that it cannot acquire it again.In fact, this situation will result in a deadblock as it will wait forever for the lock to be released so that it can be acquired, but it holds the lock and will not release it.
-
-
-<a id="org094200f"></a>
-
-### description of reentrant lock
-
-a reenrant lock will allow a thread to acquire the same lock again if it has already acquired it.This allows the thread to execute critical sections from within critical sections,as long as they are protected by same reentrant lock.
-
-each time a thread acquires the lock it must also release it, meaning that are recursive levels of acquire and release for the owning thread.As such,this type of lock is sometimes called a &ldquo;recursive mutex lock&rdquo;.
-
-
-<a id="org1082607"></a>
-
-## how to use reentrant lock
-
-    ...
-    # create reentrant lock
-    lock = RLock()
-    # acquires the lock
-    lock.acquire()
-    ...
-    # release the lock
-    lock.release()
-
-the thread attempting to acquire the lock will block until the lock is acquired, such as if another thread currently holds the lock (once or more than once) then releases it.
-
-we can use &ldquo;**blocking**&rdquo; argument and &ldquo;**timeout**&rdquo; argument like normal mutex lock.
-bonus: we can use via &rsquo;**with**&rsquo; keyword for safety.
-
-
-<a id="orge3992d5"></a>
-
-## example of using reentrant lock
-
-    
-    from __init__ import *
-    from random import random
-    
-    def report(lock,identifier):
-        with lock:
-            print(f'>thread {identifier} done')
-    
-    def task(lock,identifier,value):
-        with lock:
-            print(f'> thread {identifier} sleeping for {value}')
-            time.sleep(value)
-            report(lock,identifier)
-    lock = threading.RLock()
-    for i in range(10):
-        threading.Thread(target=task,args=(lock,i,random())).start()
-
-running the examples creates 10 threads with target as task function.
-then executes them.only one thread can acquire the lock at time,and then once acquired,blocks and then reenters the same lock again to report the done message.
-
-if non-reentrant lock,e.g. a threading.Lock was used instead,then the thread would block forever waiting for the lock to become available,which it can&rsquo;t because the thread already holds the lock.
-
-
-<a id="orga0b2eeb"></a>
-
-# thread condition - *threading.Condition*
-
-
-<a id="orga1e762e"></a>
-
-## what is a threading condition
-
-in concurency,a condition (also called a monitor) allows multiple threads to be notified about some result.
-
-it combines both a mutual exclusion lock(mutex) and a conditional variable.
-
-a mutex allow can be used to protect a critical section, but it cannot be used to alert other threads that a condition has changed or been met.
-
-a condition can be acquired by a thread(like a mutex) after which it canbe wait to be notified by another thread that something has changed. while waiting, the thread is blocked and releases the lock for other threads to acquire.
-
-another thread can then acquire the condition, make change, and notify one, all, or a subset of threads waiting on the condition that something has changed. the waiting thread can then wake-up (be scheduled by the op. sys.), reacquire the condition  (mutex), perform checks on any changed state and perform required actions.
-
-this highlights that a condition and to allow threads to notify other threads waiting on the condition.
-
-
-<a id="org97e340a"></a>
-
-## how to use condition object
-
-we can create condition object by default it will create a new reentrant mutex lock (**threading.RLock**).
-
-    ...
-    # create a new condition
-    
-    condition = threading.Condition()
-
-we may have a reentrant or non-reentrant mutex that we wish to reuse in the condition for some good reason, in which case we can provide it to the constructor.
-
-this is unrecommended unless you know your use case has this requirement.The chance of getting into trouble is high.
-
-    ...
-    # create a new condition with custom lock
-    
-    condition = threading.Condition(lock=my_lock)
-
-**we can aquire and release conditions like the Locks**
-
-    ...
-    # acquire the condition
-    condition.acquire()
-    # wait to be notified
-    condition.wait()
-    # release the condition
-    condition.release()
-    
-    # alternate way of doing same things
-    
-    # acquire the condition
-    with condition:
-        # wait to be notified
-        condition.wait()
-
-we can notify a single waitinh thread viaa the notify function.
-
-    ...
-    # acquire the condition
-    with condition:
-        # notify a waiting thread
-        condition.notify()
-    ...
-
-the notified thread will stop-blocking as soon as it can re-acquire the mutex within condition.This will be attemted automatically as part of its call to wait(), you do not need to do anything extra.
-
-if there are more than one thread waiting on the condition, we will not know which thread will be notified.
-
-we can notify all threads waitinh on yhe condition via the notify<sub>all</sub>() function.
-
-    ...
-    # acquire the condition
-    with condition:
-        # notify all threads waiting on the condition
-        condition.notify_all()
-    ...
-
-
-<a id="orgbb1f38f"></a>
-
-## example of wait and notify with a condition
-
-    from __init__ import *
-    
-    def task(condition, work_list):
-        # block for a moment
-        time.sleep(1)
-        # add data to the work list
-        work_list.append(2)
-        # notify a waiting thread that work is done
-        print('thread sending notif...')
-        with condition:
-            condition.notify()
-    
-    # create a condition
-    condition = threading.Condition()
-    work_list = list()
-    print('main thread waiting for data ...')
-    with condition:
-        # start a new thread to perform some work
-        worker = threading.Thread(target=task, args=(condition,work_list))
-        worker.start()
-        # wait to be notified
-        condition.wait()
-    # we know the data is ready
-    print(f'got data: {work_list}')
-
-
-<a id="org1e3065c"></a>
-
-# thread semaphore - *threading.Semaphore*
-
-a semaphore is essentially a counter protected by a mutex lock used to limit the number of threads that can acces a resource.
-
-
-<a id="org22f0f95"></a>
-
-## what is a semaphore
-
-a semaphore is a concurency primitive that allows a limit on the number of threads that can acquire a lock protecting a critical section.
-
-it is an extension of a mutual exclusion (mutex) lock that adds a count for the number of threads that can acquire the lock before additional threads will block. once full, new threads can only acquire a position on the semaphore once existing thread holding the semaphore releases a position.
-
-internally, the semaphore maintains a counter protected by a mutex lock that is incremented each time the semphore is acquired and decremented each time it released.
-
-when semaphore is created, the upper limit on the counter is set. If it is set to be 1, then the semphore will operate like a mutex lock.
-
-A semaphore provides a useful concurency, in examples:
-
--   limiting concurent;
-    -   socket connections to a server.
-    -   file operations on a hard drive.
-    -   calculations
-
-
-<a id="orga546941"></a>
-
-## how to use a semaphore
-
-the **threading.Semaphore** instance must be configured when it is created to set the limit on the internal counter.This limit will match the number of concurrent threads that can hold the semaphore.
-
-in example
-
-    ...
-    # create a semaphore with a limit of 100
-    semaphore = Semaphore(100)
-
-in this implementation,each time the semaphore is acquired,the internal counter is decremented. each time the semaphore is released, the internal counter is incremented.The semephore cannot be acquired if the semphore has no avaliable positions in which case, threads attempting to acquire it must block until a postion becomes avaliable.
-
-
-<a id="org7e38ed5"></a>
-
-### acquiring and releasing
-
-    ...
-    # acquire the semphore without blocking
-    semphore.acquire(blocking=False)
-    # acquire the semaphore with a timeout
-    semaphore.acquire(timeout=19)
-    # release the semaphore
-    semaphore.release()
-    
-    # acquire the semphore
-    with semphore:
-        # ...
-
-
-<a id="org6b73561"></a>
-
-## example
-
-    from __init__ import *
-    from random import random
-    
-    def task(semaphore, number:int):
-        # attempt to acquire the semaphore
-        with semaphore:
-            # process
-            value = random()
-            time.sleep(value)
-            # report result
-            print(f'thread {number} got {value}')
-    
-    # create a semaphore
-    semaphore = threading.Semaphore()
-    for i in range(10):
-        worker = threading.Thread(target=task,args=(semaphore, i))
-        worker.start()
-    # wait for all workers to complete ...
-
-
-<a id="org28fa160"></a>
-
-# thread event - *threading.Event*
-
-an event is a thread-safe boolean flag.
-
-
-<a id="org6710876"></a>
-
-## how to use event object
-
-an event is a simple pritimitve that allows communitcation between threads.
-
-a **threading.Event** object wraps a boolean variable that can either be &ldquo;set&rdquo; (**True**) or &ldquo;not set&rdquo; (**False**). threads sharing the event instance can check if the event is set and set the event or clear event (make it not set), or wait for the event to be set.
-
-the **threading.Event** provides an easy way to share a boolean variable between threads that can act as a trigger for an action.
-
-> this is one of the simplest mechanism for communitcation between threads: one thread signals an event and other threads wait for it.
-
-&#x2013; [Event objects,threading &#x2013; thread-based parallelism](https://docs.python.org/3/library/threading.html#event-objects)
-
-    ...
-    # create an instance of an event
-    # ! and the event will be in the "not set" state.
-    event = threading.Event()
-    
-    ...
-    
-    # check if the event is set
-    if event.is_set():
-        # do something ...
-    # set the event
-    event.set()
-    # mark the event as not sets
-    event.clear()
-    
-    # wait for the event to be sets
-    event.wait()
-
-<div class="org-center">
-<p>
-NOTE ⚠: waiting threads are only notified when <b>set()</b> function is called, not when <b>clear()</b> function is called
-</p>
-</div>
-
-a &ldquo;**timeout**&rdquo; argument can be passed to the **wait()** function which will limit how long a thread will return True if the event was set while waiting, otherwise a value **False** returned indicates that the event was not set and called timedout.
-
-    ...
-    # wait for the event to be set with a timeout
-    event.wait(timeout=10)
-
-
-<a id="orge51419a"></a>
-
-## example
-
-    from __init__ import *
-    from random import random
-    
-    def task(event, number):
-        # wait for the event to be set
-        event.wait()
-        # begin processing
-        value = random()
-        time.sleep(value)
-        print(f'thread {number} got {value}')
-    
-    # create a shared event object
-    event = threading.Event()
-    # create a suite of threads
-    for i in range(5):
-        thread = threading.Thread(target=task,args=(event,i))
-        thread.start()
-    # block for a moment
-    print(' main thread blocking ...')
-    time.sleep(2)
-    # start processing in all threads
-    event.set()
-    # wait for all threads to finnish ...
-
-
-<a id="org4f829c0"></a>
-
-# timer threads - *threading.Timer*
-
-a timer thread will execute a function after a time delay.
-
-
-<a id="orgbca5f69"></a>
-
-## how to use a timer thread
-
-the **threading.Timer** is an extension of fhe **threading.Thread** class because of this reason
-we can use it just like a normal thread instance.
-
-first, we can create an instance of the timer and configure it.This includes the time to wait before executing in seconds, the function to execute once triggered, adn any arguments to the target function.
-
-    ...
-    # create with configuration a timer  thread
-    timerT = threading.Timer(10,task,args=(arg1,arg2))
-    
-    # to start timer func we use
-    timerT.start()
-    # if we decide cancel the timer before target function has executed,we can use timerthread's cancel() method
-    
-    timerT.cancel()
-
-
-<a id="orgfd5839b"></a>
-
-## example of using a timer thread
-
-    from __init__ import *
-    
-    def task(message):
-        # report the message
-        print(message)
-    
-    # create a thread timer object
-    timerT = threading.Timer(3, task, args=('hello world',))
-    # start the timer object
-    timerT.start()
-    # wait for the timer to finish
-    print('waiting for the timer ...')
-
-
-<a id="orgfc2194a"></a>
-
-# thread barrier - *threading.Barrier*
-
-
-<a id="orgd25f2ce"></a>
-
-## what is barrier
-
-a barrier is a synchranization primitive.
-
-it allows multiple threads to wait on the same barrier object instance (e.g. at the same point in code) until a predefined fixed number of threads arrive (e.g. barrier is full), after which all threads are then notified and released to continue their execution.
-
-internally, a barrier maintains a count of the number of threads waiting on the barrier and a configured maximum number of parties (threads) that are expected. Once the expected number of parties reaches the pre-defined maximum, all waiting threads are notified.
-
-
-<a id="org0da4560"></a>
-
-## how to use barrier
-
-a barrier instance must first be created and configured via the constructor specifying the number of parties (threads) that must arrive before the barrier will be lifted.
-
-    ...
-    # create a barrier
-    Tbarrier = threading.Barrier(10)
-
-we can also perform an action once all threads reach the barrier which can be specified via &ldquo;action&rdquo; arg in the constructor.
-
-this action mus be callable such as a function or a lambda that does not take any arguments and will be executed by one thread once all threads reach the barrier and call the **wait()** function.
-
-    ...
-    Tbarrier = threading.Barrier(10,action=my_func)
-    # we can use timeout too
-    Tbarrier = threading.Barrier(10,action=my_func,timedout=5)
-    Tbarrier = threading.Barrier(10,timedout=5)
-
-a thread can reach and wait on the barrier via the **wait()** function.
-
-    ...
-    # wait on the barrier for all other threads to arrive
-    barrier.wait()
-
-this iss a blocking call and will return once all other threads (the pre-configured number of parties) have reached the barrier.
-
-the wait function does return an integer indicating the number of parties remaining to arrive at the barrier.If a thread was the last thread to arrive, then the return value will be zero.This is helpful if you want the last thread or one thread to perform an action after the barrier is released, and alternative to using the &ldquo;**action**&rdquo; arg in constructor.
-
-    ...
-    # wait on the barrier
-    remaining = barrier.wait()
-    # after released, check if this was the last party
-    if remaining == 0:
-        print('i was last ..')
-
-a timeout can be set on the call to wait in second via the &ldquo;**timeout**&rdquo; argument.If the timeout expires before all parties reach the  barrier, a **BrokenBarrierError** will be raised
-in all threads waiting on the barrier and the barrier will be marked as broken.
-
-if a timeout is used via &ldquo;**timeout**&rdquo; argument  or the default timeout in the constructor, then all calls to the **wait()** function may need to handle the **BrokenBarrierError**.
-
-    ...
-    # wait on the barrier for all other threads to arrive
-    try:
-        barrier.wait()
-    except BrokenBarrierError:
-        # ...
-
-we can also abort the barrier.aborting the barrier means that all threads waiting on the barrier via the **wait()** function will raise **BrokenBarrierError** and the barrier will be put in the broken state.
-
-to abort the barrier we use **abort()** function
-
-    barrier.abort()
-
-a broken barrier cannot be used.Caalls to **wait()** will raise **BrokenBarrierError**.
-
-a barrier can be fixed and made ready for use again by calling the **reset()** function.
-
-if you cancel a coodination effort although you wish to retry it again with same barrier instance.
-
-    ...
-    # reset a broken barrier
-    barrier.reset()
-
-the status of the barrier can be checked via attributes.
-
--   **parties**: reports the canfigured number of parties that must reach the barrier for it to be lifted.
--   **n<sub>waiting</sub>**: reports the current number of threads waiting on the barrier.
--   **broken**: attribute indicates whether the barrier is currently is currently broken or not.
-
-
-<a id="org96a6a28"></a>
-
-## example
-
-in this example we will create a suite of threads, each required to perform some blocking calculation we will use a barrier to coodinate all threads after they have finished their work and perform some action in the main thread. this is a good proxy for the types of coodination we may need to perform with a barrier.
-
-    from __init__ import *
-    from random import random
-    
-    # target function to prepare some work
-    def task(barrier, number):
-        # generate a unique value
-        value = random() * 10
-        # block for a moment
-        time.sleep(value)
-        # report result
-        print(f'thread {number} done, got: {value}')
-        barrier.wait()
-    # create a barrier
-    Tbarrier = threading.Barrier(5+1)
-    # create the worker threads
-    for i in range(5):
-        # start a new thread to perform some work
-        worker = threading.Thread(target=task,args=(Tbarrier,i))
-        worker.start()
-    # wait for all thread to finish
-    print('main thread waiting on all results ...')
-    Tbarrier.wait()
-    # report once all threads are done
-    print('all threads have their result')
-
-
-<a id="org84d897e"></a>
-
-# pyhton : threading best practices
-
-
-<a id="org228524f"></a>
-
-## tip 1: use context managers
-
-acquire and release locks using a context manager, wherever possible.
-
-
-<a id="org7b02d5e"></a>
-
-### not use this
-
-    ...
-    
-    # acquire the lock manually
-    lock.acquire()
-    # critical section...
-    # release the lock
-    lock.release()
-
-
-<a id="org974ed0a"></a>
-
-### use this for better control over threads (more safe)
-
-    ...
-    # acquire the lock
-    lock.acquire()
-    try:
-        # critical section ...
-    finally:
-        # always release the lock
-        lock.release()
-
-same but less code
-
-    ...
-    # acquire the lock
-    with lock:
-        # critical section ...
-
-
-<a id="org9d6d17b"></a>
-
-### the real benefit
-
-the benefit of the context manager is that the lock is always released as soon as the block exited,regardless of how it is exited, e.g normally, a return, an error, or an exception.
-
-this applies to a number of concurency primitives,such as:
-
--   acquiring ;
-    -   mutex lock via **threading.Lock** class
-    -   reentrant mutex lock via **threading.RLock** class
-    -   semaphore via **threading.Semaphore** class
-    -   condition via **threading.Condition** class
-
-
-<a id="orgb7cc37b"></a>
-
-## tip 2 : Use timedouts when waiting
-
-always use a timedout when waiting on a blocking call.
-
-many calls made on concurency primitives may block.
-
-examples:
-
--   waiting to acquire a **threading.Lock()** via **acquire()**.
--   waiting for a thread to terminate via **join()**.
--   waiting to be notified on a **threading.Condition** via **wait()**.
--   and more.
-
-All blocking calls on concurrency primitives take a &ldquo;**timeout**&rdquo; argument and return **True** if the call was successful or **False** otherwise.
-
-Do not call a blocking call without a timedout,wherever possible.
-
-    ...
-    # acquire the lock
-    if not lock.acquire(timedout=2*60):
-        # handle failure case ...
-
-this allow the waiting thread to give-up waiting after a fixed time limit and then attempt to rectify the situation, e.g. report and error, force termination, etc.
-
-
-<a id="org36c2ce4"></a>
-
-## tip 3: use a mutex to protect critical sections
-
-always use a mutual exclusion (mutex) lock to protect critical sections in code.
-
-Critical sections are sensitive parts of code that can be executed by multiple threads concurency and may result in race conditions.
-
-a critical section maay refer to a single block code, but it also refers to multiple accesses oto the same data variable or a resource from multiple functions.
-
-a mutex lock can be used to ensure that only one thread at a time executes a critical section of code at time, while all other threads trying to execute the same code must wait until the currently executing thread is finished with the critical section and releases the lock.
-
-each thread must attempt to acquire the lock at the beginning of the critical section.if the lock has not been obtained,then thread will acquire it and other threads must wait until the thread that acquired the lock releases it.
-
-    ...
-    # acquire the lock
-    with lock:
-        # critical section ...
-
-
-<a id="orge26d1f7"></a>
-
-## tip 4: acquire locks in order
-
-acquire locks in the same order throught the application, wherever possible.
-
-this is called &ldquo;lock ordering&rdquo;.
-
-in some applications you may be able to abstract the acquisition of lock using a list of **threading.Lock** object that may be itered  and acquired in order, or a function call that acquired locks in sonsistent order.
-
-when this is not possible, you may need to audit your code to confirm that all paths throught the code acquire the locks in same order.
-
-
-<a id="org6784994"></a>
-
-# python : threading common errors
-
-
-<a id="orgca7c287"></a>
-
-## race conditions
-
-
-<a id="org9804145"></a>
-
-## thread deadlocks
-
-
-<a id="org75500b0"></a>
-
-## thread livelocks
-
-
-<a id="org47c70b9"></a>
-
-# python threading common questions
-
-**\*
-\***
-**\*
-\***
-**\*
-\***
-**\*
-\***
-**\*
-\***
-\*\*
-
-
-<a id="org1fb73c4"></a>
-
-# resources
-
--   <https://superfastpython.com/threading-in-python/#Python_Threads>
-
diff --git a/python/threading_parallel_processing/threading.org b/python/threading_parallel_processing/threading.org
index 2a8b703..6f249c2 100644
--- a/python/threading_parallel_processing/threading.org
+++ b/python/threading_parallel_processing/threading.org
@@ -1,44 +1,45 @@
 #+title: Threading in Python
 #+author: mal1kc
 #+startup: showeverything
-#+options: toc:3
 
-* what are threads
+* Python Threads
+
+** what are threads
 threads refers to thread of execution in computer program
 
 #+BEGIN_QUOTE
-Thread: The operating system object that executes the instructions of a process
-- book: page 273,the art of concurrency,2009.
+Thread: The operating system object that executess the instructions of a process
+- book: page 273,the art of concurency,2009.
 #+END_QUOTE
 
 when we run python script, it starts an instance of python interpreter that runs our code in the main thread.
 the main threads is the default thread of a python process
 
-we may develop our program to  perform tasks concurrently in that case we may need threads,these are concurrent threads of execution without our program
+we may develop our program to  perform tasks concurently in that case we may need threads,these are concurent threads of execution without our program
 example of this will be:
 
-- execution function calls concurrently
-- execution object methods concurrently
+- execution funtion calls concurently
+- execution object methods concurently
 
 a python thread is an object representation of native thread provided by operating system
 
-when we create and run a new thread, Python will make system calls on the underlying op. system and request new thread be created and start running new thread
+when we create and run a new thread, Python will make system calls on the underlaying op. system and request new thread be created and start running new thread
 
-the code in new threads may or may not be executed in parallel,even though the threads are executed concurrently.
+the code in new threads may or may not be executed in parallel,even though the threads are executed concurently.
 
 these are number of reasons for this,such as:
 
-- the underlying hardware may or may not support parallel execution (e.g. one vs multiple CPU cores)
-- the python interpreter may or may not permits multiple threads execute in parallel
+- the underlaying hardware may or may not support parallel execution (e.g. one vs multiple CPU cores)
+- the python interpreter may or may not permity multiple threads execute in parallel
 
 #+begin_quote
- this highlights the distraction between concurrent and parallel execution
+ this highlights the distiction between concurent and parallel execution
 #+end_quote
 
 - *Concurrent* : Code that can be executed out of order
 - *Parallel* : Capability to execute code simultaneously
 
-* thread vs process
+** thread vs process
 
 a process refers to a computer process
 
@@ -46,7 +47,7 @@ a process refers to a computer process
 process: the operating system's spawned and controlled entity that encapsulates an executing application.
 a process has two main functions. the first is to act as the resource holder for the application,
 and the second is to execute the instructions of the application.
-- book: page 271,the art of concurrency,2009
+- book: page 271,the art of concurency,2009
 #+END_QUOTE
 
 the op system controls how new processes are created on some system,that may require spawning a new process,and on others,it may require that process is forked.
@@ -60,60 +61,60 @@ threads that we create within the process will belong to that process.
 
 the python process will terminate once all(non background threads) are terminated
 
-- *process*: an instance of the python interpreter has at least one thread called MainThread
+- *process*: an instance of the python interpreter has atleast one thread called MainThread
 - *thread*: a thread of execution within Python process,such as the MainThread or new thread.
 
-* life-cycle of thread
+** life-cycle of thread
 
 a thread in python is object instanced from  *threading.Thread* class
 
-once a thread is started, interpreter will interface with the operating system and request that new native thread be created. the instance of *threading.Thread*
-the provides a python-based reference to his underlying native thread.
+once a thead is started, interpreter will interface with the operating system and request that new native thread be created. the instance of *threading.Thread*
+the provides a python-based reference to his underlaying native thread.
 
 each thread follows same life-cycle . understanding of its life-cycle help with
-concurrent programming in python.
+concurent programming in python.
 
 for example:
 
-- the difference between creating and starting a thread
+- the diffrence between creatimg and starting a thread
 
-- the difference between run and start
+- the diffrence between run and start
 
-- the difference between blocked and terminated
+- the diffrence between blocked and terminated
 
-while running, the thread may be executing code or may be blocked,waiting on something such as another thread or external resource.although, not all threads may block, it is optional base on specific use case for the new thread.
+while running, the thread may be executing code or may be blocked,waiting on something such as another thread or external resource.although, not all threads may block, it is optinal base on specific use case for the new thread.
 
 1. new thread
 2. running thread
-    1. blocked thread (optional).
+    1. blocked thread (optinal).
 3. terminated thread.
 
 A new thread is a thread that has been constructed by. creating an instance of the *threading.Thread* class
 
 a new thread can transition to a running thread by calling the start() function.
 
-a running thread may block in many ways, such as reading or writing from a file or a socket or by waiting on concurrency primitive such as semaphore or a lock
+a running thread may block in many ways, such as reading or writing from a file or a socket or by waiting on concurency primitive such as semaphore or a lock
 after blocking,the thread will run again.
 
-finally, a thread may terminate once it has finished executing its code or by raising
+finaly, a thread may terminate once it has finished executing its code or by raising
 error or exception
 
-[[./thread-life-cycle.webp][thread life cycle diagram]]
+[[(thread life cycle diaram)./thread-life-cycle.webp]]
 
 * run a func in thread
 
-python funcs can executed in a separate thread using *threading.Thread* class
+python funcs can executed in a seperatie thread using *threading.Thread* class
 
 ** how to run a func in thread
 
-the func executed in another thread may have args in which case can be specified as aa tuple and passed to the "*args*" argument of the threading.threading class constructor or as dictionary to the "*kwargs*" argument.
+the func executed in another thread may have args in which case can be specificed as aa tuple and passed to the "*args*" argument of the threading.threading class constructor or as dictionart to the "*kwargs*" argument.
 
-the *start()* func will return immediately and the operating system will execute    the function in a separate thread as soon as it is able.
+the *start()* func will return immediately and the operating system will execute    the function in a seperate thread as soon as it is able.
 
-we do not have control over when the thread will execute precisely or which cpu core will execute it. both of these are low-level responsibilities that are handled by operating system.
+we do not have control over when the thread will execute precisely or which cpu core wwill execute it. both of these are low-level responsibilities that are handled by operating system.
 
 #+begin_quote
- doing necessary imports for examples
+ doing nessesary imports for examples
 #+end_quote
 
 #+begin_src python :shebang "#!/bin/env python" :tangle __init__.py
@@ -145,7 +146,7 @@ thread.join() # explicitly waiting to finish thread
 
 #+RESULTS:
 
-running the example first creates instance  of threading.Thread then calls the *start()* func.This does not start the thread immediately,but instead allows to operating system to schedule the function to execute as soon as possible.
+running the example first creates instance  of threeding.Thread then calls the *start()* func.This does not start the thread immediately,but instead allows to operating system to schedule the function to execute as soon as possible.
 
 the main thread then prints a message '/waiting .../' ,then calls the *join()* function to explicitly block and wait for the new thread to finish executing.
 
@@ -175,11 +176,11 @@ In this section we will look at some examples of extending *thread.Thread* class
 
 ** possible usage cases
 
-given that it is a custom class,you can define a constructor for the class and use it to pass in data that may be needed in the *run()* function, stored as instance variables (attributes).
+given that it is a custom class,you can defina a constructor for the class and use it to pass in data that may be needed in the *run()* function, stored as instance variables (attributes).
 
 you can also define additional functions on the class to split up the work you may need to complete another thread.
 
-finally, attributes can also be used to store the results of any calculation or IO performed in another thread that may be need to be retrieved afterward.
+finally, attributes caan also be used to store the results of any calculation or IO performed in another thread that may be need to be retrieved afterward.
 
 ** example of extending the thread class
 
@@ -254,7 +255,7 @@ print(f'{value=}')
 * thread instance attributes
 
 an instance of the thread class provides a handle of a thread of execution.
-it provides attributes that we can use to query properties and the status of the underlying thread.
+it provides attributes that we can use to query properties and the status of the underlaying thread.
 
 ** thread name
 
@@ -262,7 +263,7 @@ threads are named automatically in a somewhat unique manner within each process
 
 ** thread daemon
 
-a thread may be a daemon thread, daemon threads is the name given to background threads.by default threads are non-daemon threads.
+a thread may be a deamon thread, daemon threads is the name givent to background threads.by default threads are non-daemon threads.
 
 a python program will only exit when all non-daemon threads have finished exiting. for example , the main threads is a non-daemon threads.this means that daemon threads can run in the background and do not have to finish or be explicitly excited for the program end.
 
@@ -272,15 +273,15 @@ each thread has unique identifier (id) within python process,assigned by python
 
 the identifier is a read-only positive integer value and is assigned only after thread has been started.
 
-can be accessed via *"ident"* property
+can be accesed via *"ident"* property
 
 ** thread native identifier
 
 each thread has unique identifier assigned by the operating system.
 
-python threads (cpython) are real native threads,means that each thread we created is actually created and managed (scheduled) by operating system.As such, the operating system will assign a unique integer to each thread that is created on the system (across processes).
+python threads (cpython) are real native threads,means that each thread we created is actually created and managed (scheduled) by operating system.As such, the operating system will assing a unique integer to each thread that is created on the system (across processes).
 
-can be accessed via *"native_id"* property
+can be acced via *"native_id"* property
 
 it is assigned after thread has been started
 
@@ -367,7 +368,7 @@ there is a "main thread" object;this corresponds to initial thread of control in
 #+end_quote
 -- [[https://docs.python.org/3/library/threading.html][threading -- Thread-based parallelism]]
 
-we can acquire a main thread by calling *threading.current_thread()*
+we can acquire a main thread by calling *threadin.current_thread()*
 
 #+begin_src python :shebang "#!/bin/env python" :tangle threading_example_07.py
 from __init__ import *
@@ -395,9 +396,9 @@ print(f'thread;\n{thread.name=},{thread.daemon=},{thread.ident=}')
 
 *threading.get_ident()* gives current threads identifier integer that assigned by operating system
 
-** enumerate active threads
+** enumarate active threads
 
-we can get a list of active threads via calling *threading.enumerate()* function,it returns list of active threads
+we can get a list of active threads via calling *threading.enumarate()* function,it returns list of active threads
 
 #+begin_src python :shebang "#!/bin/env python" :tangle threading_example_08.py
 
@@ -424,8 +425,8 @@ thread.join()
 
 an unhandled exception can occur in a new thread.
 
-the effect will be that the thread will unwind and report the message on standard
-error.Unwinding the thread means that the thread will stop executing at the point of the (or error) and that the exception will bubble up the stack in the thread until it reaches the top level,e.g. the run() function.
+the effect will be that the thread will unwind and report the message on standart
+error.Unwinding the thread means that the thread will stop executing at the point of the (or error) and that the exception will bubble up the stack in the thread until it reaches the top level,e.g. the run() funtion.
 
 
 #+begin_src python :shebang "#!/bin/env python" :tangle threading_example_09.py
@@ -448,7 +449,7 @@ print('finished')
 
 ** exception hook
 
-we can specify how to handle unhandled errors and exceptions that occur within new threads via the exception hook
+we can specify how to handle unhandled errors aand exceptions that occuur within new threads via the exception hook
 
 by default,there is no exception hook, in which case the *[[https://docs.python.org/3/library/sys.html#sys.excepthook][sys.excepthook function]]*
 is called that reports the familiar message.
@@ -482,7 +483,7 @@ print('finished')
 
 python interpreter generally does not permit more than one thread to run at a time
 
-this is achieved via mutual exclusion (mutex) lock within interpreter that ensures that only one thread at a time can execute python bytecodes in python virtual machine .
+this is achieved via mutal exclusion (mutex) lock within interpreter that ensures that only one thread at a time can execute python bytecodes in python virtual machine .
 
 #+begin_quote
 In CPython, due to the Global Interpreter Lock, only one thread can execute Python code at once (even though certain performance-oriented libraries might overcome this limitation).
@@ -495,16 +496,16 @@ In CPython, the global interpreter lock, or GIL, is a mutex that protects access
 #+end_quote
 -- [[https://wiki.python.org/moin/GlobalInterpreterLock][GLOBAL INTERPRETER LOCK, PYTHON WIKI]]
 
-this means that although we might write concurrent code  with threads and run our code  on hardware with many CPU cores, we may not be able to execute our code in parallel
+this means that although we might write concurent code  with threads and run our code  on hardware with many CPU cores, we may not be able to execute our code in parallel
 
 there are some exceptions to this.
 
 specially, the *GIL* is released by the Python interpreter sometimes to allow other threads to run.
 
-such as when the thread is blocked ,such as performing IO with socket or file, or often if the thread is executing computationally intensive code in C library,like hashing bytes.
+such as when the thread is blocked ,such as performing IO with socket or file, or often if the thread is executing computationally intesive code in C library,like hashing bytes.
 
 #+begin_quote
-Luckily, many potentially blocking or long-running operations, such as I/O, image processing, and NumPy number crunching, happen outside the GIL. Therefore it is only in multi-threaded programs that spend a lot of time inside the GIL, interpreting CPython bytecode, that the GIL becomes a bottleneck.
+Luckily, many potentially blocking or long-running operations, such as I/O, image processing, and NumPy number crunching, happen outside the GIL. Therefore it is only in multithreaded programs that spend a lot of time inside the GIL, interpreting CPython bytecode, that the GIL becomes a bottleneck.
 #+end_quote
 -- [[https://wiki.python.org/moin/GlobalInterpreterLock][GLOBAL INTERPRETER LOCK, PYTHON WIKI]]
 
@@ -512,7 +513,7 @@ therefore, although in most cases Cpython will prevent parallel execution of thr
 
 * when to use thread
 
-there are times when the GIL lock is released by the interpreter and we can achieve  parallel execution of our concurrent code in python.
+there are times when the GIL lock is released by the interpreter and we can achieve  parallel execution of our concurent code in python.
 
 *examples of when lock is released include:*
 
@@ -528,7 +529,7 @@ there are times when the GIL lock is released by the interpreter and we can achi
 
 should use threads for IO bound tasks.
 
-an IO-bound task is a type of task that involves reading from or writing to device, file, or socket connection.
+an IO-bound task is a type of tash that involves reading from or writing to device, file, or socket connection.
 
 modern CPUs, like a 4GHz CPU, can execute 4 billion instructions per second, and you likely have more than one CPU core in your system.
 
@@ -540,7 +541,7 @@ that is probably preventing billions of operations from executing.
 
 a thread performing an IO operation will block for the duration of the operation.While blocked,this signals to the operating system that a thread can be suspended and onether thread can execute, called a context switch.
 
-additionally, python interpreter will release the GIL when performing blocking IO operations,allowing other threads within the python process to execute.
+additonally, python interpreter will release the GIL when performing blocking IO operations,allowing other threads within the python process to execute.
 
 therefore, blocking IO provides an excellent use case for using threads in python.
 
@@ -548,13 +549,13 @@ therefore, blocking IO provides an excellent use case for using threads in pytho
 
     - reading or writing a file from the hard drive.
 
-    - reading or writing to standard output, input or error(stdin,stdout,stderr).
+    - reading or writing to standart output, input or error(stdin,stdout,stderr).
 
     - printing a document.
 
     - reading or writing bytes on a socket connection with a server.
 
-    - downloading or uploading a file.
+    - downloading or uplading a file.
 
     - query a server.
 
@@ -562,15 +563,15 @@ therefore, blocking IO provides an excellent use case for using threads in pytho
 
     - taking a photo.
 
-    - everything that includes disk write read
+    - everythin that includes disk write read
 
-** use threads external c code (that releases the GIL)
+** use threads external c code (that realses the GIL)
 
 we may make function calls that themselves call down into a third-party C library.
 
-Often these function calls will release the GIL as the C library being called will not interact with the interpreter.
+Often these function calls will realase the GIL as the C library being called will not interact with the intpreter.
 
-this provides an opportunity for other threads in the python process to run.
+this provides an opputunity for other threads in the python process to run.
 
 *for example*,when using the "*hash*" module in python std library,the GIL is released when hashing the data via the [[https://docs.python.org/3/library/hashlib.html#hashlib.hash.update][hash.update() function]]
 
@@ -588,9 +589,9 @@ The exceptions are few but important: while a thread is waiting for IO (for you
 
 ** use threads with (some) third-party python interpreter
 
-there are alternate commercial and open source python interpreters that you can acquire and use to execute your python code.
+there are alternate commericial and open source python interpreters that you can acquire and use to execute your python code.
 
-some python interpreters may implement a GIL and release it more or less than Cpython. Other interpreters remove the GIL entirely and allow multiple python concurrent threads to execute in parallel.
+some python interpreters may implement a GIL and release it more or less than Cpython. Other interpreters remove the GIL entirely and allow multiple python concurent threads to execute in parallel.
 
 * threads blocking calls
 
@@ -612,7 +613,7 @@ similarly, many function calls that we may traditionally think block may have no
 
 there are three types of blocking function calls you need to consider in concurrent programming, they are:
 
-- blocking calls on concurrent primitives
+- blocking calls on concurent primitives
 
 - blocking calls for IO
 
@@ -632,16 +633,16 @@ common ways are;
 
 ** blocking calls for I/O
 
-conventionally,function calls that interact with I/O are mostly blocking calls.they are blocking in same sense as blocking calls in concurrency primitives
+conventionally,function calls that interact with I/O are mostly blocking calls.they are blocking in same sencse as blocking calls in concurency primitives
 the wait for the I/O device respond is another signal to operating system that the thread can be context switched.
 
 common examples are;
 
 - *hdd(hard disk drive)* :reading,writing,appending,renaming,deleting,.. files
-- *perpheral devices*    :mouse,keyboard,screen,printer,camera,serial device etc.
+- *perpheral devices*    :mouse,keyboard,screen,printe,camera,serial device etc.
 - *database*             :sql queries
-- *internet*             :downloading,uploading,http requests,etc.
-  - *email*                :send,receive,query inbox,etc.
+- *internet*             :downloading,uplading,http requests,etc.
+  - *email*                :send,receieve,querry inbox,etc.
 - *and more,mostly other socket related things*
 
 performing I/O operations with devices is typically very slow compared to CPU operations.
@@ -664,11 +665,11 @@ time.sleep(5)
 #+end_src
 it is a blocking call it signals to the operating system that the thread is waiting and is a good candidate for a context switch.
 
-sleeps are often used when timing is important in an application.
+sleeps are often ısed when timing is important in an application.
 
 in programming, adding a sleep can be useful way to simulate waiting within fixed interval.
 
-sleep often used in worked examples when demonstrating concurrency programming,but adding sleeps to code can also aid in unit testing and debugging concurrency failure conditions,such as race conditions by forcing mistiming of events within a dynamic application
+sleep often used in worked examples when demonstrating concurrency programming,but adding sleeps to code can also aid in unit testing and debugging concurency failure conditions,such as race conditions by forcing mistiming of events within a dynamic application
 
 * thread-local data
 threads can store local data via an instance of the *threading.local* class
@@ -685,8 +686,8 @@ local.custom = 33
 #+end_src
 
 importantly,other threads can use the same property names on local but the values will be limited to each thread.
-this is like a namespace limited to each thread and is called "thread-local data".it means that threads cannot access or read the local data of other threads.
-importantly, each thread must hang on to the "local" instance in order to access the stored data.
+this is like a namespace limited to each thread and is called "thread-local data".it means that threads cannot acces or read the local data of other threads.
+importantly, each thread must hang on to the "local" instance in order to acces the stored data.
 
 ** example
 
@@ -714,15 +715,15 @@ threading.Thread(target=task,args=(2,)).start()
 ** what is mutual exclusion lock
 *** why we need mutual exclusion lock
 #+begin_center
-a _mutual exclusion lock_ is a synchronization primitive intended to prevent a race condition.
+a _mutual exclusion lock_ is a synchronization primitive intented to prevent a race condition.
 
-a race conditions is a concurrency failure case when two threads run same code and access or update same resource leaving the resource unknown and inconsistent state.
-these sensitive parts of cade that can be executed by multiple threads concurrently and may result in race conditions are called critical sections, a critical
+a race conditions is a concurency failure case when two threads run same code and access or update same resource leaving the resource unkown and inconsistent state.
+these censitive parts of cade that can be executed by multiple threads concurently and may result in race conditions are called critical sections, a critical
 section may refer to single block of code, but is also refers to multiple accesses to the same data variable or resource from multiple functions.
 #+end_center
 *** description of mutex
 #+begin_center
-mutual exclusion lock also known as mutex,is synchronization mechanism used to control access to a shared resource in concurent system.A mutex is essentially a binary semaphore (e.g railroad switch signals) with two states;locked and unlocked.When a thread acquires a mutex,it sets the lock to locked state,preventing other threads from also acquiring the lock.The thread that acquire the lock is said to have exclusive access to the shared resource.When the thread releases the lock.The thread that acquired the lock is said to gave exclusive access to the shared resource.When the thread releases the lock,it sets the lock to the unlocked state, allowing other thread to acquire the lock and gain access to the shared resource.this mechanism ensures that only one thread can access resource at a time, preventing race conditions and other synchronization issues.
+mutual exclusion lock also known as mutex,is synchronization mechanism used to control acces to a shared resource in concurent system.A mutex is essentially a binary semaphore (e.g railroad switch signals) with two states;locked and unlocked.When a thread acquires a mutex,it sets the lock to locked state,preventing other threads from also acquiring the lock.The thread that acquire the lock is said to have exclusive acces to the shared resource.When the thread releases the lock.The thread that acquired the lock is said to gave exclusive access to the shared resource.When the thread releases the lock,it sets the lock to the unlocked state, allowing other thread to acquire the lock and gain access to the shared resource.this mechanism ensures that only one thread can access resource at a time, preventing race conditions and other synchronization issues.
 #+end_center
 ** how to use mutex lock
 #+begin_center
@@ -770,7 +771,7 @@ with lock:
     # ...
 #+end_src
 
-this is proffered usage as it makes it clear where the protected code starts and ends,and ensures that the lock is always released, even if there is an exception or error within the critical section.
+this is preffered usage as it makes it clear where the protected code starts and ends,and ensures that the lock is always released, even if there is an exception or error within the critical section.
 
 also we can check if the lock is currently acquired by a thread
 
@@ -806,11 +807,11 @@ for i in range(10):
 ** what is reentrant lock
 a reentrant mutual exclusion lock aka "reenrant mutex" or "reentrant lock" for short, is like a mutex lock except it allows a thread to acquire the lock more than once.
 #+begin_quote
-a reentrant lock is synchronization primitive that may be acquired multiple times by the same thread [...] In the locked state,some thread owns the lock;in the unlocked state no thread owns it
+a reentrant lock is synchranization primitive that may be acquired multiple times by the same thread [...] In the locked state,some thread owns the lock;in the unlocked state no thread owns it
 #+end_quote
 -- [[https://docs.python.org/3/library/threading.html#rlock-objects.html][rlock objects -- Thread-based parallelism]]
-*** why we need reentrant lock
-we can imagine critical sections spread across a number of functions,each protected by the same lock.A thread may call across these functions in course of normal execution and may call into one critical section from another critical section.
+*** why we neet reentrant lock
+we can imagine critical sections spread across a number of funcstions,each protected by the same lock.A thread may call across these functions in course of normal execution and may call into one critical section from another critical section.
 
 a limitation of a (non-reentrant) mutex lock is that if a thread has acquired the lock that it cannot acquire it again.In fact, this situation will result in a deadblock as it will wait forever for the lock to be released so that it can be acquired, but it holds the lock and will not release it.
 
@@ -867,13 +868,13 @@ if non-reentrant lock,e.g. a threading.Lock was used instead,then the thread wou
 * thread condition - /threading.Condition/
 ** what is a threading condition
 
-in concurrency,a condition (also called a monitor) allows multiple threads to be notified about some result.
+in concurency,a condition (also called a monitor) allows multiple threads to be notified about some result.
 
 it combines both a mutual exclusion lock(mutex) and a conditional variable.
 
 a mutex allow can be used to protect a critical section, but it cannot be used to alert other threads that a condition has changed or been met.
 
-a condition can be acquired by a thread(like a mutex) after which it can be wait to be notified by another thread that something has changed. while waiting, the thread is blocked and releases the lock for other threads to acquire.
+a condition can be acquired by a thread(like a mutex) after which it canbe wait to be notified by another thread that something has changed. while waiting, the thread is blocked and releases the lock for other threads to acquire.
 
 another thread can then acquire the condition, make change, and notify one, all, or a subset of threads waiting on the condition that something has changed. the waiting thread can then wake-up (be scheduled by the op. sys.), reacquire the condition  (mutex), perform checks on any changed state and perform required actions.
 
@@ -901,7 +902,7 @@ condition = threading.Condition(lock=my_lock)
 
 #+end_src
 
-*we can acquire and release conditions like the Locks*
+*we can aquire and release conditions like the Locks*
 
 #+begin_src  python
 ...
@@ -920,7 +921,7 @@ with condition:
     condition.wait()
 #+end_src
 
-we can notify a single waiting thread via the notify function.
+we can notify a single waitinh thread viaa the notify function.
 
 #+begin_src python
 ...
@@ -932,11 +933,11 @@ with condition:
 
 #+end_src
 
-the notified thread will stop-blocking as soon as it can re-acquire the mutex within condition.This will be attempted automatically as part of its call to wait(), you do not need to do anything extra.
+the notified thread will stop-blocking as soon as it can re-acquire the mutex within condition.This will be attemted automatically as part of its call to wait(), you do not need to do anything extra.
 
 if there are more than one thread waiting on the condition, we will not know which thread will be notified.
 
-we can notify all threads waiting on the condition via the notify_all() function.
+we can notify all threads waitinh on yhe condition via the notify_all() function.
 #+begin_src python
 ...
 # acquire the condition
@@ -980,19 +981,19 @@ print(f'got data: {work_list}')
 
 * thread semaphore - /threading.Semaphore/
 
-a semaphore is essentially a counter protected by a mutex lock used to limit the number of threads that can access a resource.
+a semaphore is essentially a counter protected by a mutex lock used to limit the number of threads that can acces a resource.
 
 ** what is a semaphore
-a semaphore is a concurrency primitive that allows a limit on the number of threads that can acquire a lock protecting a critical section.
+a semaphore is a concurency primitive that allows a limit on the number of threads that can acquire a lock protecting a critical section.
 
 it is an extension of a mutual exclusion (mutex) lock that adds a count for the number of threads that can acquire the lock before additional threads will block. once full, new threads can only acquire a position on the semaphore once existing thread holding the semaphore releases a position.
 
-internally, the semaphore maintains a counter protected by a mutex lock that is incremented each time the semaphore is acquired and decremented each time it released.
+internally, the semaphore maintains a counter protected by a mutex lock that is incremented each time the semphore is acquired and decremented each time it released.
 
-when semaphore is created, the upper limit on the counter is set. If it is set to be 1, then the semaphore will operate like a mutex lock.
+when semaphore is created, the upper limit on the counter is set. If it is set to be 1, then the semphore will operate like a mutex lock.
 
-A semaphore provides a useful concurrency, in examples:
-- limiting concurrent;
+A semaphore provides a useful concurency, in examples:
+- limiting concurent;
   - socket connections to a server.
   - file operations on a hard drive.
   - calculations
@@ -1008,7 +1009,7 @@ in example
 semaphore = Semaphore(100)
 #+end_src
 
-in this implementation,each time the semaphore is acquired,the internal counter is decremented. each time the semaphore is released, the internal counter is incremented.The semaphore cannot be acquired if the semaphore has no available positions in which case, threads attempting to acquire it must block until a position becomes available.
+in this implementation,each time the semaphore is acquired,the internal counter is decremented. each time the semaphore is released, the internal counter is incremented.The semephore cannot be acquired if the semphore has no avaliable positions in which case, threads attempting to acquire it must block until a postion becomes avaliable.
 
 *** acquiring and releasing
 
@@ -1053,14 +1054,14 @@ for i in range(10):
 * thread event - /threading.Event/
 an event is a thread-safe boolean flag.
 ** how to use event object
-an event is a simple primitive that allows communication between threads.
+an event is a simple pritimitve that allows communitcation between threads.
 
 a *threading.Event* object wraps a boolean variable that can either be "set" (*True*) or "not set" (*False*). threads sharing the event instance can check if the event is set and set the event or clear event (make it not set), or wait for the event to be set.
 
 the *threading.Event* provides an easy way to share a boolean variable between threads that can act as a trigger for an action.
 
 #+begin_quote
-this is one of the simplest mechanism for communication between threads: one thread signals an event and other threads wait for it.
+this is one of the simplest mechanism for communitcation between threads: one thread signals an event and other threads wait for it.
 #+end_quote
 
 -- [[https://docs.python.org/3/library/threading.html#event-objects][Event objects,threading -- thread-based parallelism]]
@@ -1089,7 +1090,7 @@ event.wait()
 NOTE ⚠: waiting threads are only notified when *set()* function is called, not when *clear()* function is called
 #+end_center
 
-a "*timeout*" argument can be passed to the *wait()* function which will limit how long a thread will return True if the event was set while waiting, otherwise a value *False* returned indicates that the event was not set and called timed out.
+a "*timeout*" argument can be passed to the *wait()* function which will limit how long a thread will return True if the event was set while waiting, otherwise a value *False* returned indicates that the event was not set and called timedout.
 
 #+begin_src  python
 ...
@@ -1127,10 +1128,10 @@ event.set()
 a timer thread will execute a function after a time delay.
 ** how to use a timer thread
 
-the *threading.Timer* is an extension of the *threading.Thread* class because of this reason
+the *threading.Timer* is an extension of fhe *threading.Thread* class because of this reason
 we can use it just like a normal thread instance.
 
-first, we can create an instance of the timer and configure it.This includes the time to wait before executing in seconds, the function to execute once triggered, and any arguments to the target function.
+first, we can create an instance of the timer and configure it.This includes the time to wait before executing in seconds, the function to execute once triggered, adn any arguments to the target function.
 
 #+begin_src python
 ...
@@ -1163,7 +1164,7 @@ print('waiting for the timer ...')
 
 * thread barrier - /threading.Barrier/
 ** what is barrier
-a barrier is a synchronization primitive.
+a barrier is a synchranization primitive.
 
 it allows multiple threads to wait on the same barrier object instance (e.g. at the same point in code) until a predefined fixed number of threads arrive (e.g. barrier is full), after which all threads are then notified and released to continue their execution.
 
@@ -1197,7 +1198,7 @@ a thread can reach and wait on the barrier via the *wait()* function.
 barrier.wait()
 #+end_src
 
-this is a blocking call and will return once all other threads (the pre-configured number of parties) have reached the barrier.
+this iss a blocking call and will return once all other threads (the pre-configured number of parties) have reached the barrier.
 
 the wait function does return an integer indicating the number of parties remaining to arrive at the barrier.If a thread was the last thread to arrive, then the return value will be zero.This is helpful if you want the last thread or one thread to perform an action after the barrier is released, and alternative to using the "*action*" arg in constructor.
 
@@ -1231,11 +1232,11 @@ to abort the barrier we use *abort()* function
 barrier.abort()
 #+end_src
 
-a broken barrier cannot be used.Calls to *wait()* will raise *BrokenBarrierError*.
+a broken barrier cannot be used.Caalls to *wait()* will raise *BrokenBarrierError*.
 
 a barrier can be fixed and made ready for use again by calling the *reset()* function.
 
-if you cancel a coordination effort although you wish to retry it again with same barrier instance.
+if you cancel a coodination effort although you wish to retry it again with same barrier instance.
 
 #+begin_src python
 ...
@@ -1245,13 +1246,13 @@ barrier.reset()
 
 the status of the barrier can be checked via attributes.
 
-- *parties*: reports the configured number of parties that must reach the barrier for it to be lifted.
+- *parties*: reports the canfigured number of parties that must reach the barrier for it to be lifted.
 - *n_waiting*: reports the current number of threads waiting on the barrier.
 - *broken*: attribute indicates whether the barrier is currently is currently broken or not.
 
 ** example
 
-in this example we will create a suite of threads, each required to perform some blocking calculation we will use a barrier to coordinate all threads after they have finished their work and perform some action in the main thread. this is a good proxy for the types of coordination we may need to perform with a barrier.
+in this example we will create a suite of threads, each required to perform some blocking calculation we will use a barrier to coodinate all threads after they have finished their work and perform some action in the main thread. this is a good proxy for the types of coodination we may need to perform with a barrier.
 
 #+begin_src python :shebang "#!/bin/env python" :tangle threading_example_18.py
 from __init__ import *
@@ -1324,7 +1325,7 @@ with lock:
 
 the benefit of the context manager is that the lock is always released as soon as the block exited,regardless of how it is exited, e.g normally, a return, an error, or an exception.
 
-this applies to a number of concurrency primitives,such as:
+this applies to a number of concurency primitives,such as:
 
 - acquiring ;
   - mutex lock via *threading.Lock* class
@@ -1335,7 +1336,7 @@ this applies to a number of concurrency primitives,such as:
 ** tip 2 : Use timedouts when waiting
 always use a timedout when waiting on a blocking call.
 
-many calls made on concurrency primitives may block.
+many calls made on concurency primitives may block.
 
 examples:
 
@@ -1360,9 +1361,9 @@ this allow the waiting thread to give-up waiting after a fixed time limit and th
 ** tip 3: use a mutex to protect critical sections
 always use a mutual exclusion (mutex) lock to protect critical sections in code.
 
-Critical sections are sensitive parts of code that can be executed by multiple threads concurrency and may result in race conditions.
+Critical sections are sensitive parts of code that can be executed by multiple threads concurency and may result in race conditions.
 
-a critical section may refer to a single block code, but it also refers to multiple accesses to the same data variable or a resource from multiple functions.
+a critical section maay refer to a single block code, but it also refers to multiple accesses oto the same data variable or a resource from multiple functions.
 
 a mutex lock can be used to ensure that only one thread at a time executes a critical section of code at time, while all other threads trying to execute the same code must wait until the currently executing thread is finished with the critical section and releases the lock.
 
@@ -1378,35 +1379,29 @@ with lock:
 
 ** tip 4: acquire locks in order
 
-acquire locks in the same order through the application, wherever possible.
+acquire locks in the same order throught the application, wherever possible.
 
 this is called "lock ordering".
 
-in some applications you may be able to abstract the acquisition of lock using a list of *threading.Lock* object that may be iterated  and acquired in order, or a function call that acquired locks in consistent order.
-
-when this is not possible, you may need to audit your code to confirm that all paths through the code acquire the locks in same order.
-
-# * python : threading common errors
-# ** race conditions
-# ** thread deadlocks
-# ** thread livelocks
-# * python threading common questions
-# **
-# **
-# **
-# **
-# **
-# **
-# **
-# **
-# **
-# **
-# **
-
-if you want to read more about look [[#-resources][at the there]]
+in some applications you may be able to abstract the acquisition of lock using a list of *threading.Lock* object that may be itered  and acquired in order, or a function call that acquired locks in sonsistent order.
+
+when this is not possible, you may need to audit your code to confirm that all paths throught the code acquire the locks in same order.
+
+* python : threading common errors
+** race conditions
+** thread deadlocks
+** thread livelocks
+* python threading common questions
+**
+**
+**
+**
+**
+**
+**
+**
+**
+**
+**
 * resources
  - https://superfastpython.com/threading-in-python/#Python_Threads
-
-* what is this document
-
- this documents my notes that mostly  (most of examples and how example works) copied,rewrite in my understandings, from given sources
diff --git a/requirments.txt b/requirments.txt
new file mode 100644
index 0000000..363562f
--- /dev/null
+++ b/requirments.txt
@@ -0,0 +1,3 @@
+autopep8==1.6.0
+pycodestyle==2.8.0
+toml==0.10.2
